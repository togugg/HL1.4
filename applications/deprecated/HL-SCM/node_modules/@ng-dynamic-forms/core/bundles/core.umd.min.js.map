{"version":3,"file":"core.umd.min.js","sources":["../../../es5/core/src/utils/core.utils.ts","../../../es5/core/src/component/dynamic-form-control.component.ts","../../../es5/core/src/component/dynamic-form-array.component.ts","../../../es5/core/src/component/dynamic-form-control.event.ts","../../../es5/core/src/component/dynamic-form-component.ts","../../../../node_modules/tslib/tslib.es6.js","../../../../node_modules/rxjs/src/internal/config.ts","../../../../node_modules/rxjs/src/internal/Observer.ts","../../../../node_modules/rxjs/src/internal/util/isObject.ts","../../../../node_modules/rxjs/src/internal/util/tryCatch.ts","../../../../node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","../../../../node_modules/rxjs/src/internal/Subscription.ts","../../../../node_modules/rxjs/src/internal/symbol/rxSubscriber.ts","../../../../node_modules/rxjs/src/internal/Subscriber.ts","../../../../node_modules/rxjs/src/internal/Observable.ts","../../../../node_modules/rxjs/src/internal/util/toSubscriber.ts","../../../../node_modules/rxjs/src/internal/util/canReportError.ts","../../../../node_modules/rxjs/src/internal/util/pipe.ts","../../../../node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","../../../../node_modules/rxjs/src/internal/SubjectSubscription.ts","../../../../node_modules/rxjs/src/internal/Subject.ts","../../../../node_modules/rxjs/src/internal/operators/refCount.ts","../../../../node_modules/rxjs/src/internal/observable/ConnectableObservable.ts","../../../../node_modules/rxjs/src/internal/observable/empty.ts","../../../../node_modules/rxjs/src/internal/util/subscribeToArray.ts","../../../../node_modules/rxjs/src/internal/observable/fromArray.ts","../../../../node_modules/rxjs/src/internal/observable/of.ts","../../../../node_modules/rxjs/src/internal/observable/scalar.ts","../../../../node_modules/rxjs/src/internal/util/isObservable.ts","../../../../node_modules/rxjs/src/internal/operators/map.ts","../../../es5/core/src/decorator/serializable.decorator.ts","../../../es5/core/src/model/dynamic-form-control.model.ts","../../../es5/core/src/model/dynamic-form-value-control.model.ts","../../../es5/core/src/model/form-array/dynamic-form-array.model.ts","../../../es5/core/src/model/dynamic-check-control.model.ts","../../../es5/core/src/model/checkbox/dynamic-checkbox.model.ts","../../../es5/core/src/utils/autofill.utils.ts","../../../es5/core/src/model/dynamic-input-control.model.ts","../../../es5/core/src/utils/json.utils.ts","../../../../node_modules/rxjs/src/internal/operators/tap.ts","../../../es5/core/src/model/input/dynamic-input.model.ts","../../../es5/core/src/model/misc/dynamic-form-control-relation.model.ts","../../../es5/core/src/utils/relation.utils.ts","../../../es5/core/src/component/dynamic-form-control-container.component.ts","../../../es5/core/src/component/dynamic-templateable-form-control.component.ts","../../../es5/core/src/directive/dynamic-id.directive.ts","../../../es5/core/src/directive/dynamic-list.directive.ts","../../../es5/core/src/directive/dynamic-template.directive.ts","../../../es5/core/src/model/dynamic-date-control.model.ts","../../../es5/core/src/model/dynamic-file-control.model.ts","../../../es5/core/src/model/dynamic-option-control.model.ts","../../../es5/core/src/model/form-group/dynamic-form-group.model.ts","../../../es5/core/src/model/checkbox/dynamic-checkbox-group.model.ts","../../../es5/core/src/model/colorpicker/dynamic-colorpicker.model.ts","../../../es5/core/src/model/datepicker/dynamic-datepicker.model.ts","../../../es5/core/src/model/editor/dynamic-editor.model.ts","../../../es5/core/src/model/file-upload/dynamic-file-upload.model.ts","../../../es5/core/src/model/radio/dynamic-radio-group.model.ts","../../../es5/core/src/model/rating/dynamic-rating.model.ts","../../../es5/core/src/model/select/dynamic-select.model.ts","../../../es5/core/src/model/slider/dynamic-slider.model.ts","../../../es5/core/src/model/switch/dynamic-switch.model.ts","../../../es5/core/src/model/textarea/dynamic-textarea.model.ts","../../../es5/core/src/model/timepicker/dynamic-timepicker.model.ts","../../../es5/core/src/service/dynamic-form-validation.service.ts","../../../es5/core/src/service/dynamic-form.service.ts","../../../es5/core/src/service/dynamic-form-layout.service.ts","../../../es5/core/src/core.module.ts"],"sourcesContent":["export function isBoolean(value: any): value is boolean {\n    return typeof value === \"boolean\";\n}\n\nexport function isFunction(value: any): value is Function {\n    return typeof value === \"function\";\n}\n\nexport function isNumber(value: any): value is number {\n    return typeof value === \"number\";\n}\n\nexport function isObject(value: any): value is object {\n    return typeof value === \"object\" && value !== null;\n}\n\nexport function isString(value: any): value is string {\n    return typeof value === \"string\";\n}\n","import { EventEmitter } from \"@angular/core\";\nimport { FormControl, FormGroup } from \"@angular/forms\";\nimport { DynamicFormControl } from \"./dynamic-form-control.interface\";\nimport { DynamicFormControlCustomEvent } from \"./dynamic-form-control.event\";\nimport { DynamicFormControlModel } from \"../model/dynamic-form-control.model\";\nimport { DynamicCheckboxModel } from \"../model/checkbox/dynamic-checkbox.model\";\nimport {\n    DynamicFormControlLayout,\n    DynamicFormControlLayoutContext,\n    DynamicFormControlLayoutPlace\n} from \"../model/misc/dynamic-form-control-layout.model\";\nimport { DynamicFormValidationService } from \"../service/dynamic-form-validation.service\";\nimport {\n    DynamicFormLayout,\n    DynamicFormLayoutService,\n    DynamicFormControlTemplates\n} from \"../service/dynamic-form-layout.service\";\nimport { isString } from \"../utils/core.utils\";\n\nexport abstract class DynamicFormControlComponent implements DynamicFormControl {\n\n    private _hasFocus: boolean = false;\n\n    group: FormGroup;\n    layout: DynamicFormLayout;\n    model: DynamicFormControlModel;\n    templates: DynamicFormControlTemplates;\n\n    blur: EventEmitter<any>;\n    change: EventEmitter<any>;\n    customEvent: EventEmitter<DynamicFormControlCustomEvent> | undefined;\n    focus: EventEmitter<any>;\n\n    protected constructor(protected layoutService: DynamicFormLayoutService,\n                          protected validationService: DynamicFormValidationService) {}\n\n    get control(): FormControl {\n        return this.group.get(this.model.id) as FormControl;\n    }\n\n    get elementId(): string {\n        return this.layoutService.getElementId(this.model);\n    }\n\n    get errorMessages(): string[] {\n        return this.validationService.createErrorMessages(this.control, this.model);\n    }\n\n    get hasFocus(): boolean {\n        return this._hasFocus;\n    }\n\n    get isInvalid(): boolean {\n        return this.control.invalid;\n    }\n\n    get isValid(): boolean {\n        return this.control.valid;\n    }\n\n    get showErrorMessages(): boolean {\n        return this.model.hasErrorMessages && this.control.touched && !this.hasFocus && this.isInvalid;\n    }\n\n    getClass(context: DynamicFormControlLayoutContext, place: DynamicFormControlLayoutPlace, model: DynamicFormControlModel = this.model): string {\n\n        let controlLayout = (this.layout && this.layout[model.id]) || model.layout as DynamicFormControlLayout;\n\n        return this.layoutService.getClass(controlLayout, context, place);\n    }\n\n    onBlur($event: any) {\n\n        if ($event instanceof Event) {\n            $event.stopPropagation();\n        }\n\n        this._hasFocus = false;\n        this.blur.emit($event);\n    }\n\n    onChange($event: any) {\n\n        if ($event instanceof Event) {\n            $event.stopPropagation();\n        }\n\n        this.change.emit($event);\n    }\n\n    onEmbeddedCheckboxChange($event: Event, model: DynamicCheckboxModel) {\n\n        this.onChange($event);\n\n        model.valueUpdates.next(($event.target as HTMLInputElement).checked);\n    }\n\n    onCustomEvent($event: any, type: string | null = null, bypass: boolean = false) {\n\n        let emitter = this.customEvent as EventEmitter<DynamicFormControlCustomEvent>;\n\n        if (bypass) {\n\n            emitter.emit($event);\n\n        } else if (isString(type)) {\n\n            emitter.emit({customEvent: $event, customEventType: type});\n        }\n    }\n\n    onFocus($event: any) {\n\n        if ($event instanceof Event) {\n            $event.stopPropagation();\n        }\n\n        this._hasFocus = true;\n        this.focus.emit($event);\n    }\n}\n","import { QueryList } from \"@angular/core\";\nimport { DynamicFormControlComponent } from \"./dynamic-form-control.component\";\nimport { DynamicTemplateDirective } from \"../directive/dynamic-template.directive\";\nimport { DynamicFormArrayModel } from \"../model/form-array/dynamic-form-array.model\";\n\nexport abstract class DynamicFormArrayComponent extends DynamicFormControlComponent {\n\n    model: DynamicFormArrayModel;\n    templates: QueryList<DynamicTemplateDirective> | undefined;\n\n    get startTemplate(): DynamicTemplateDirective | undefined {\n        return this.layoutService.getStartTemplate(this.model, this.templates);\n    }\n\n    get endTemplate(): DynamicTemplateDirective | undefined {\n        return this.layoutService.getEndTemplate(this.model, this.templates);\n    }\n}","import { FormControl, FormGroup } from \"@angular/forms\";\nimport { DynamicFormControlModel } from \"../model/dynamic-form-control.model\";\nimport { DynamicFormArrayGroupModel } from \"../model/form-array/dynamic-form-array.model\";\nimport { isObject } from \"../utils/core.utils\";\n\nexport enum DynamicFormControlEventType {Blur = \"blur\", Change = \"change\", Custom = \"custom\", Focus = \"focus\"}\n\nexport interface DynamicFormControlEvent {\n\n    $event: Event | FocusEvent | DynamicFormControlEvent | any;\n    context: DynamicFormArrayGroupModel | null;\n    control: FormControl;\n    group: FormGroup;\n    model: DynamicFormControlModel;\n    type: string;\n}\n\nexport interface DynamicFormControlCustomEvent {\n\n    customEvent: any;\n    customEventType: string;\n}\n\nexport function isDynamicFormControlEvent($event: any): $event is DynamicFormControlEvent {\n    return isObject($event) && $event.hasOwnProperty(\"$event\");\n}","import { EventEmitter, QueryList } from \"@angular/core\";\nimport { FormGroup } from \"@angular/forms\";\nimport { DynamicFormControlContainerComponent } from \"./dynamic-form-control-container.component\";\nimport { DynamicFormControlEvent, DynamicFormControlEventType } from \"./dynamic-form-control.event\";\nimport { DynamicFormControlModel } from \"../model/dynamic-form-control.model\";\nimport { DynamicFormModel } from \"../model/dynamic-form.model\";\nimport {\n    DynamicFormControlLayout,\n    DynamicFormControlLayoutContext,\n    DynamicFormControlLayoutPlace\n} from \"../model/misc/dynamic-form-control-layout.model\";\nimport { DynamicTemplateDirective } from \"../directive/dynamic-template.directive\";\nimport { DynamicFormService } from \"../service/dynamic-form.service\";\nimport { DynamicFormLayout, DynamicFormLayoutService } from \"../service/dynamic-form-layout.service\";\n\nexport abstract class DynamicFormComponent {\n\n    formGroup: FormGroup;\n    formModel: DynamicFormModel;\n    formLayout: DynamicFormLayout;\n\n    components: QueryList<DynamicFormControlContainerComponent>;\n    templates: QueryList<DynamicTemplateDirective>;\n\n    blur: EventEmitter<DynamicFormControlEvent>;\n    change: EventEmitter<DynamicFormControlEvent>;\n    focus: EventEmitter<DynamicFormControlEvent>;\n    customEvent: EventEmitter<DynamicFormControlEvent>;\n\n    protected constructor(protected formService: DynamicFormService, protected layoutService: DynamicFormLayoutService) {}\n\n    trackByFn(_index: number, model: DynamicFormControlModel): string {\n        return model.id;\n    }\n\n    getClass(model: DynamicFormControlModel, context: DynamicFormControlLayoutContext, place: DynamicFormControlLayoutPlace): string {\n\n        let controlLayout = this.layoutService.findById(model.id, this.formLayout) || model.layout as DynamicFormControlLayout;\n\n        return this.layoutService.getClass(controlLayout, context, place);\n    }\n\n    onEvent($event: DynamicFormControlEvent, type: string) {\n\n        switch (type) {\n\n            case DynamicFormControlEventType.Blur:\n                this.blur.emit($event);\n                break;\n\n            case DynamicFormControlEventType.Change:\n                this.change.emit($event);\n                break;\n\n            case DynamicFormControlEventType.Focus:\n                this.focus.emit($event);\n                break;\n\n            case DynamicFormControlEventType.Custom:\n                this.customEvent.emit($event);\n                break;\n        }\n    }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","let _enable_super_gross_mode_that_will_cause_bad_things = false;\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like what Promise contructor should used to create Promises\n */\nexport const config = {\n  /**\n   * The promise constructor used by default for methods such as\n   * {@link toPromise} and {@link forEach}\n   */\n  Promise: undefined as PromiseConstructorLike,\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME\n   * FOR MIGRATION REASONS.\n   */\n  set useDeprecatedSynchronousErrorHandling(value: boolean) {\n    if (value) {\n      const error = new Error();\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n      console.log('RxJS: Back to a better error behavior. Thank you. <3');\n    }\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  },\n};\n","import { Observer } from './types';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete(): void { /*noop*/ }\n};\n","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n}\n","export interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  new(errors: any[]): UnsubscriptionError;\n}\n\nfunction UnsubscriptionErrorImpl(this: any, errors: any[]) {\n  Error.call(this);\n  this.message = errors ?\n  `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '';\n  this.name = 'UnsubscriptionError';\n  this.errors = errors;\n  return this;\n}\n\nUnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = UnsubscriptionErrorImpl as any;","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic } from './types';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY: Subscription = (function(empty: any) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  /** @internal */\n  protected _parent: Subscription = null;\n  /** @internal */\n  protected _parents: Subscription[] = null;\n  /** @internal */\n  private _subscriptions: SubscriptionLike[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  /** @internal */\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","/** @deprecated do not use, this is no longer checked by RxJS internals */\nexport const rxSubscriber =\n  typeof Symbol === 'function'\n    ? Symbol('rxSubscriber')\n    : '@@rxSubscriber_' + Math.random();\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","import { isFunction } from './util/isFunction';\nimport { empty as emptyObserver } from './Observer';\nimport { Observer, PartialObserver, TeardownLogic } from './types';\nimport { Subscription } from './Subscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  /** @internal */ syncErrorValue: any = null;\n  /** @internal */ syncErrorThrown: boolean = false;\n  /** @internal */ syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any> | Subscriber<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  private _parentSubscription: Subscription | null = null;\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            this.destination = destinationOrNext;\n            destinationOrNext.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    this._parentSubscription = null;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      const { useDeprecatedSynchronousErrorHandling } = config;\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @internal This is an internal implementation detail, do not use. */\n  _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n","import { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, PartialObserver, Subscribable } from './types';\nimport { canReportError } from './util/canReportError';\nimport { toSubscriber } from './util/toSubscriber';\nimport { iif } from './observable/iif';\nimport { throwError } from './observable/throwError';\nimport { observable as Symbol_observable } from '../internal/symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  /** Internal implementation detail, do not use directly. */\n  public _isScalar: boolean = false;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  source: Observable<any>;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   * @nocollapse\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * ## Example\n   * ### Subscribe with an Observer\n   * ```javascript\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Subscribe with functions\n   * ```javascript\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Cancel a subscription\n   * ```javascript\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(\n        this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?\n        this._subscribe(sink) :\n        this._trySubscribe(sink)\n      );\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n      if (canReportError(sink)) {\n        sink.error(err);\n      } else {\n        console.warn(err);\n      }\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    }) as Promise<void>;\n  }\n\n  /** @internal This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    const { source } = this;\n    return source && source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words. Deprecated in\n  // favor of iif and throwError functions.\n  /**\n   * @nocollapse\n   * @deprecated In favor of iif creation function: import { iif } from 'rxjs';\n   */\n  static if: typeof iif;\n  /**\n   * @nocollapse\n   * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';\n   */\n  static throw: typeof throwError;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>, ...operations: OperatorFunction<any, any>[]): Observable<{}>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ### Example\n   * ```javascript\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  if (!promiseCtor) {\n    promiseCtor = config.Promise || Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { empty as emptyObserver } from '../Observer';\nimport { PartialObserver } from '../types';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { Subscriber } from '../Subscriber';\nimport { Subject } from '../Subject';\n\n/**\n * Determines whether the ErrorObserver is closed or stopped or has a\n * destination that is closed or stopped - in which case errors will\n * need to be reported via a different mechanism.\n * @param observer the observer\n */\nexport function canReportError(observer: Subscriber<any> | Subject<any>): boolean {\n  while (observer) {\n    const { closed, destination, isStopped } = observer as any;\n    if (closed || isStopped) {\n      return false;\n    } else if (destination && destination instanceof Subscriber) {\n      observer = destination;\n    } else {\n      observer = null;\n    }\n  }\n  return true;\n}\n","import { noop } from './noop';\nimport { UnaryFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>, ...fns: UnaryFunction<any, any>[]): UnaryFunction<T, {}>;\n/* tslint:enable:max-line-length */\n\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","export interface ObjectUnsubscribedError extends Error {\n}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  new(): ObjectUnsubscribedError;\n}\n\nfunction ObjectUnsubscribedErrorImpl(this: any) {\n  Error.call(this);\n  this.message = 'object unsubscribed';\n  this.name = 'ObjectUnsubscribedError';\n  return this;\n}\n\nObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = ObjectUnsubscribedErrorImpl as any;","import { Subject } from './Subject';\nimport { Observer } from './types';\nimport { Subscription } from './Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SubjectSubscription<T> extends Subscription {\n  closed: boolean = false;\n\n  constructor(public subject: Subject<T>, public subscriber: Observer<T>) {\n    super();\n  }\n\n  unsubscribe() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const subject = this.subject;\n    const observers = subject.observers;\n\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    const subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  }\n}\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\n\n/**\n * @class SubjectSubscriber<T>\n */\nexport class SubjectSubscriber<T> extends Subscriber<T> {\n  constructor(protected destination: Subject<T>) {\n    super(destination);\n  }\n}\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observables. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n *\n * @class Subject<T>\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n\n  [rxSubscriberSymbol]() {\n    return new SubjectSubscriber(this);\n  }\n\n  observers: Observer<T>[] = [];\n\n  closed = false;\n\n  isStopped = false;\n\n  hasError = false;\n\n  thrownError: any = null;\n\n  constructor() {\n    super();\n  }\n\n  /**@nocollapse */\n  static create: Function = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  }\n\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = <any>operator;\n    return <any>subject;\n  }\n\n  next(value?: T) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    if (!this.isStopped) {\n      const { observers } = this;\n      const len = observers.length;\n      const copy = observers.slice();\n      for (let i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n    this.observers.length = 0;\n  }\n\n  complete() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n    this.observers.length = 0;\n  }\n\n  unsubscribe() {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return super._trySubscribe(subscriber);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription(this, subscriber);\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create customize Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return {Observable} Observable that the Subject casts to\n   */\n  asObservable(): Observable<T> {\n    const observable = new Observable<T>();\n    (<any>observable).source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(protected destination?: Observer<T>, source?: Observable<T>) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    const { destination } = this;\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  }\n\n  error(err: any) {\n    const { destination } = this;\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  }\n\n  complete() {\n    const { destination } = this;\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    const { source } = this;\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription.EMPTY;\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Observable } from '../Observable';\n\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return function refCountOperatorFunction(source: ConnectableObservable<T>): Observable<T> {\n    return source.lift(new RefCountOperator(source));\n  } as MonoTypeOperatorFunction<T>;\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // )\n    // .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Subject, SubjectSubscriber } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { TeardownLogic } from '../types';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n\n  protected _subject: Subject<T>;\n  protected _refCount: number = 0;\n  protected _connection: Subscription;\n  /** @internal */\n  _isComplete = false;\n\n  constructor(public source: Observable<T>,\n              protected subjectFactory: () => Subject<T>) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      } else {\n        this._connection = connection;\n      }\n    }\n    return connection;\n  }\n\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n\nconst connectableProto = <any>ConnectableObservable.prototype;\n\nexport const connectableObservableDescriptor: PropertyDescriptorMap = {\n  operator: { value: null },\n  _refCount: { value: 0, writable: true },\n  _subject: { value: null, writable: true },\n  _connection: { value: null, writable: true },\n  _subscribe: { value: connectableProto._subscribe },\n  _isComplete: { value: connectableProto._isComplete, writable: true },\n  getSubject: { value: connectableProto.getSubject },\n  connect: { value: connectableProto.connect },\n  refCount: { value: connectableProto.refCount }\n};\n\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\n  constructor(destination: Subject<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n  protected _error(err: any): void {\n    this._unsubscribe();\n    super._error(err);\n  }\n  protected _complete(): void {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  protected _unsubscribe() {\n    const connectable = <any>this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // ).subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * The same Observable instance returned by any call to {@link empty} without a\n * `scheduler`. It is preferrable to use this over `empty()`.\n */\nexport const EMPTY = new Observable<never>(subscriber => subscriber.complete());\n\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.\n * </span>\n *\n * ![](empty.png)\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the complete notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n * ### Emit the number 7, then complete\n * ```javascript\n * const result = empty().pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * ### Map and flatten only odd numbers to the sequence 'a', 'b', 'c'\n * ```javascript\n * const interval$ = interval(1000);\n * result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : empty()),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval eg(0,1,2,3,...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1 print abc\n * // if x % 2 is not equal to 1 nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link never}\n * @see {@link of}\n * @see {@link throwError}\n *\n * @param {SchedulerLike} [scheduler] A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @return {Observable} An \"empty\" Observable: emits only the complete\n * notification.\n * @static true\n * @name empty\n * @owner Observable\n * @deprecated Deprecated in favor of using {@link index/EMPTY} constant.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nexport function emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>(subscriber => scheduler.schedule(() => subscriber.complete()));\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Subscribes to an ArrayLike with a subscriber\n * @param array The array or array-like to subscribe to\n */\nexport const subscribeToArray = <T>(array: ArrayLike<T>) => (subscriber: Subscriber<T>) => {\n  for (let i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n    subscriber.next(array[i]);\n  }\n  if (!subscriber.closed) {\n    subscriber.complete();\n  }\n};\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\nimport { subscribeToArray } from '../util/subscribeToArray';\n\nexport function fromArray<T>(input: ArrayLike<T>, scheduler?: SchedulerLike) {\n  if (!scheduler) {\n    return new Observable<T>(subscribeToArray(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      let i = 0;\n      sub.add(scheduler.schedule(function () {\n        if (i === input.length) {\n          subscriber.complete();\n          return;\n        }\n        subscriber.next(input[i++]);\n        if (!subscriber.closed) {\n          sub.add(this.schedule());\n        }\n      }));\n      return sub;\n    });\n  }\n}\n","import { SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { fromArray } from './fromArray';\nimport { empty } from './empty';\nimport { scalar } from './scalar';\nimport { Observable } from '../Observable';\n\n/* tslint:disable:max-line-length */\nexport function of<T>(a: T, scheduler?: SchedulerLike): Observable<T>;\nexport function of<T, T2>(a: T, b: T2, scheduler?: SchedulerLike): Observable<T | T2>;\nexport function of<T, T2, T3>(a: T, b: T2, c: T3, scheduler?: SchedulerLike): Observable<T | T2 | T3>;\nexport function of<T, T2, T3, T4>(a: T, b: T2, c: T3, d: T4, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;\nexport function of<T, T2, T3, T4, T5>(a: T, b: T2, c: T3, d: T4, e: T5, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\nexport function of<T, T2, T3, T4, T5, T6>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function of<T, T2, T3, T4, T5, T6, T7>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, scheduler?: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7>;\nexport function of<T, T2, T3, T4, T5, T6, T7, T8>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, scheduler?: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8>;\nexport function of<T, T2, T3, T4, T5, T6, T7, T8, T9>(a: T, b: T2, c: T3, d: T4, e: T5, f: T6, g: T7, h: T8, i: T9, scheduler?: SchedulerLike):\n  Observable<T | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9>;\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```javascript\n * of(10, 20, 30)\n * .subscribe(\n *   next => console.log('next:', next),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'next: 10'\n * // 'next: 20'\n * // 'next: 30'\n *\n * ```\n *\n * Emit the array `[1,2,3]`\n *\n * ```javascript\n * of([1,2,3])\n * .subscribe(\n *   next => console.log('next:', next),\n *   err => console.log('error:', err),\n *   () => console.log('the end'),\n * );\n * // result:\n * // 'next: [1,2,3]'\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param {...T} values A comma separated list of arguments you want to be emitted\n * @return {Observable} An Observable that emits the arguments\n * described above and then completes.\n * @method of\n * @owner Observable\n */\n\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  let scheduler = args[args.length - 1] as SchedulerLike;\n  if (isScheduler(scheduler)) {\n    args.pop();\n  } else {\n    scheduler = undefined;\n  }\n  switch (args.length) {\n    case 0:\n      return empty(scheduler);\n    case 1:\n      return scheduler ? fromArray(args as T[], scheduler) : scalar(args[0] as T);\n    default:\n      return fromArray(args as T[], scheduler);\n  }\n}\n","import { Observable } from '../Observable';\n\nexport function scalar<T>(value: T) {\n  const result = new Observable<T>(subscriber => {\n    subscriber.next(value);\n    subscriber.complete();\n  });\n  result._isScalar = true;\n  (result as any).value = value;\n  return result;\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput } from '../types';\n\n/**\n * Tests to see if the object is an RxJS {@link Observable}\n * @param obj the object to test\n */\nexport function isObservable<T>(obj: any): obj is Observable<T> {\n  return !!obj && (obj instanceof Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n * Map every click to the clientX position of that click\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return function mapOperation(source: Observable<T>): Observable<R> {\n    if (typeof project !== 'function') {\n      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return source.lift(new MapOperator(project, thisArg));\n  };\n}\n\nexport class MapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => R, private thisArg: any) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber<T, R> extends Subscriber<T> {\n  count: number = 0;\n  private thisArg: any;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => R,\n              thisArg: any) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  // NOTE: This looks unoptimized, but it's actually purposefully NOT\n  // using try/catch optimizations.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","declare let Reflect: any;\n\nexport const METADATA_KEY_SERIALIZABLE = \"SERIALIZABLE\";\n\nexport interface SerializableProperty {\n\n    key: string;\n    name: string;\n}\n\nexport function serializable(name?: string): (target: any, key: string) => void {\n\n    return function (target, key) {\n        Reflect.defineMetadata(METADATA_KEY_SERIALIZABLE, {key: key, name: name || key}, target, key);\n    };\n}\n\nexport function getSerializables(target: any): SerializableProperty[] {\n\n    let serializables = [];\n\n    for (let key in target) {\n\n        let metadata = Reflect.getMetadata(METADATA_KEY_SERIALIZABLE, target, key);\n\n        if (metadata) {\n            serializables.push(metadata);\n        }\n    }\n\n    return serializables;\n}\n\nexport function serialize(target: any, prototype?: any): Object {\n\n    return getSerializables(prototype || target).reduce((prev: any, prop: SerializableProperty) => {\n\n        prev[prop.name] = target[prop.key];\n\n        return prev;\n\n    }, {});\n}","import { FormHooks } from \"@angular/forms/src/model\";\nimport { Subject } from \"rxjs\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { DynamicPathable } from \"./misc/dynamic-form-control-path.model\";\nimport { DynamicFormControlRelationGroup } from \"./misc/dynamic-form-control-relation.model\";\nimport { DynamicValidatorsConfig } from \"./misc/dynamic-form-control-validation.model\";\nimport { serializable, serialize } from \"../decorator/serializable.decorator\";\nimport { isBoolean, isObject, isString } from \"../utils/core.utils\";\n\nexport interface DynamicFormControlModelConfig {\n\n    asyncValidators?: DynamicValidatorsConfig;\n    disabled?: boolean;\n    errorMessages?: DynamicValidatorsConfig;\n    hidden?: boolean;\n    id: string;\n    label?: string;\n    labelTooltip?: string;\n    controlTooltip?: string;\n    name?: string;\n    relation?: DynamicFormControlRelationGroup[];\n    updateOn?: FormHooks;\n    validators?: DynamicValidatorsConfig;\n}\n\nexport abstract class DynamicFormControlModel implements DynamicPathable {\n\n    @serializable() asyncValidators: DynamicValidatorsConfig | null;\n    @serializable(\"disabled\") _disabled: boolean;\n    disabledUpdates: Subject<boolean>;\n    @serializable() errorMessages: DynamicValidatorsConfig | null;\n    @serializable() hidden: boolean;\n    @serializable() id: string;\n    @serializable() label: string | null;\n    @serializable() labelTooltip: string | null;\n    @serializable() controlTooltip: string | null;\n    @serializable() layout: DynamicFormControlLayout | null;\n    @serializable() name: string;\n    parent: DynamicPathable | null = null;\n    @serializable() relation: DynamicFormControlRelationGroup[];\n    @serializable() updateOn: FormHooks | null;\n    @serializable() validators: DynamicValidatorsConfig | null;\n\n    abstract readonly type: string;\n\n    protected constructor(config: DynamicFormControlModelConfig, layout: DynamicFormControlLayout | null = null) {\n\n        this.asyncValidators = config.asyncValidators || null;\n        this.errorMessages = config.errorMessages || null;\n        this.hidden = isBoolean(config.hidden) ? config.hidden : false;\n        this.id = config.id;\n        this.label = config.label || null;\n        this.labelTooltip = config.labelTooltip || null;\n        this.controlTooltip = config.controlTooltip || null;\n        this.layout = layout;\n        this.name = config.name || config.id;\n        this.relation = Array.isArray(config.relation) ? config.relation : [];\n        this.updateOn = isString(config.updateOn) ? config.updateOn : null;\n        this.validators = config.validators || null;\n\n        this.disabled = isBoolean(config.disabled) ? config.disabled : false;\n        this.disabledUpdates = new Subject<boolean>();\n        this.disabledUpdates.subscribe(disabled => this.disabled = disabled);\n    }\n\n    get disabled(): boolean {\n        return this._disabled;\n    }\n\n    set disabled(value: boolean) {\n        this._disabled = value;\n    }\n\n    get hasErrorMessages(): boolean {\n        return isObject(this.errorMessages);\n    }\n\n    toJSON() {\n        return serialize(this);\n    }\n}","import { Subject } from \"rxjs\";\nimport { DynamicFormControlModel, DynamicFormControlModelConfig } from \"./dynamic-form-control.model\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../decorator/serializable.decorator\";\nimport { isBoolean, isObject } from \"../utils/core.utils\";\n\nexport interface DynamicFormValueControlModelConfig<T> extends DynamicFormControlModelConfig {\n\n    additional?: { [key: string]: any };\n    hint?: string;\n    required?: boolean;\n    tabIndex?: number;\n    value?: T;\n}\n\nexport abstract class DynamicFormValueControlModel<T> extends DynamicFormControlModel {\n\n    @serializable() additional: { [key: string]: any } | null;\n    @serializable() hint: string | null;\n    @serializable() required: boolean;\n    @serializable() tabIndex: number | null;\n    @serializable(\"value\") _value: T | null;\n    valueUpdates: Subject<T>;\n\n    protected constructor(config: DynamicFormValueControlModelConfig<T>, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.additional = isObject(config.additional) ? config.additional : null;\n        this.hint = config.hint || null;\n        this.required = isBoolean(config.required) ? config.required : false;\n        this.tabIndex = config.tabIndex || null;\n\n        this.value = config.value !== null && config.value !== undefined ? config.value : null;\n        this.valueUpdates = new Subject<T>();\n        this.valueUpdates.subscribe((value: T) => this.value = value);\n    }\n\n    set value(value: T | null) {\n        this._value = value;\n    }\n\n    get value(): T | null {\n        return this._value;\n    }\n\n    getAdditional(key: string, defaultValue: any = null): any {\n        return this.additional !== null && this.additional.hasOwnProperty(key) ? this.additional[key] : defaultValue;\n    }\n}","import { DynamicFormControlModel, DynamicFormControlModelConfig } from \"../dynamic-form-control.model\";\nimport { DynamicFormModel } from \"../dynamic-form.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { DynamicPathable } from \"../misc/dynamic-form-control-path.model\";\nimport { DynamicValidatorsConfig } from \"../misc/dynamic-form-control-validation.model\";\nimport { serializable, serialize } from \"../../decorator/serializable.decorator\";\nimport { isFunction, isNumber } from \"../../utils/core.utils\";\n\nexport class DynamicFormArrayGroupModel implements DynamicPathable {\n\n    $implicit: DynamicFormArrayGroupModel;\n    context: DynamicFormArrayModel;\n    @serializable() group: DynamicFormModel;\n    @serializable() index: number;\n\n    constructor(context: DynamicFormArrayModel, group: DynamicFormModel = [], index: number = -1) {\n\n        this.$implicit = this;\n        this.context = context;\n        this.group = group;\n        this.index = index;\n    }\n\n    get parent(): DynamicFormArrayModel {\n        return this.context;\n    }\n\n    get(index: number): DynamicFormControlModel {\n        return this.group[index];\n    }\n\n    toJSON() {\n        return serialize(this);\n    }\n}\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_ARRAY = \"ARRAY\";\n\nexport interface DynamicFormArrayModelConfig extends DynamicFormControlModelConfig {\n\n    groupAsyncValidators?: DynamicValidatorsConfig;\n    groupFactory?: () => DynamicFormModel;\n    groupValidators?: DynamicValidatorsConfig;\n    groups?: DynamicFormArrayGroupModel[] | null;\n    initialCount?: number;\n}\n\nexport class DynamicFormArrayModel extends DynamicFormControlModel {\n\n    @serializable() groupAsyncValidators: DynamicValidatorsConfig | null;\n    groupFactory: () => DynamicFormModel;\n    @serializable() groupValidators: DynamicValidatorsConfig | null;\n    @serializable() groups: DynamicFormArrayGroupModel[] = [];\n    @serializable() initialCount: number;\n\n    @serializable() readonly groupPrototype: DynamicFormModel; // only to recreate model from JSON\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_ARRAY;\n\n    constructor(config: DynamicFormArrayModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        if (isFunction(config.groupFactory)) {\n            this.groupFactory = config.groupFactory;\n        } else {\n            throw new Error(\"group factory function must be specified for DynamicFormArrayModel\");\n        }\n\n        this.groupAsyncValidators = config.groupAsyncValidators || null;\n        this.groupPrototype = this.groupFactory();\n        this.groupValidators = config.groupValidators || null;\n        this.initialCount = isNumber(config.initialCount) ? config.initialCount : 1;\n\n        if (Array.isArray(config.groups)) {\n\n            config.groups.forEach((arrayGroup, index) => {\n                this.groups.push(new DynamicFormArrayGroupModel(this, arrayGroup.group, arrayGroup.index || index));\n            });\n\n        } else {\n\n            for (let index = 0; index < this.initialCount; index++) {\n                this.addGroup();\n            }\n        }\n    }\n\n    private updateGroupIndex(): void {\n        this.groups.forEach((group, index) => group.index = index);\n    }\n\n    get size(): number {\n        return this.groups.length;\n    }\n\n    get(index: number): DynamicFormArrayGroupModel {\n        return this.groups[index];\n    }\n\n    addGroup(): DynamicFormArrayGroupModel {\n        return this.insertGroup(this.groups.length);\n    }\n\n    insertGroup(index: number): DynamicFormArrayGroupModel {\n\n        let group = new DynamicFormArrayGroupModel(this, this.groupFactory());\n\n        this.groups.splice(index, 0, group);\n        this.updateGroupIndex();\n\n        return group;\n    }\n\n    moveGroup(index: number, step: number): void {\n\n        this.groups.splice(index + step, 0, ...this.groups.splice(index, 1));\n        this.updateGroupIndex();\n    }\n\n    removeGroup(index: number): void {\n\n        this.groups.splice(index, 1);\n        this.updateGroupIndex();\n    }\n}\n","import { DynamicFormValueControlModel, DynamicFormValueControlModelConfig } from \"./dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../decorator/serializable.decorator\";\nimport { isBoolean } from \"../utils/core.utils\";\n\nexport interface DynamicCheckControlModelConfig extends DynamicFormValueControlModelConfig<boolean> {\n\n    labelPosition?: string;\n}\n\nexport abstract class DynamicCheckControlModel extends DynamicFormValueControlModel<boolean> {\n\n    @serializable() labelPosition: string | null;\n\n    protected constructor(config: DynamicCheckControlModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.labelPosition = config.labelPosition || null;\n        this.value = isBoolean(this.value) ? this.value : false;\n    }\n\n    get checked(): boolean {\n        return !!this.value;\n    }\n\n    set checked(checked: boolean) {\n        this.valueUpdates.next(checked);\n    }\n\n    toggle(): void {\n        this.checked = !this.checked;\n    }\n}","import { DynamicCheckControlModel, DynamicCheckControlModelConfig } from \"../dynamic-check-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\nimport { isBoolean } from \"../../utils/core.utils\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX = \"CHECKBOX\";\n\nexport interface DynamicCheckboxModelConfig extends DynamicCheckControlModelConfig {\n\n    indeterminate?: boolean;\n}\n\nexport class DynamicCheckboxModel extends DynamicCheckControlModel {\n\n    @serializable() indeterminate: boolean;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX;\n\n    constructor(config: DynamicCheckboxModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.indeterminate = isBoolean(config.indeterminate) ? config.indeterminate : false;\n    }\n}","export const AUTOCOMPLETE_OFF = \"off\";\nexport const AUTOCOMPLETE_ON = \"on\";\n\nexport const AUTOFILL_TOKEN_BILLING = \"billing\";\nexport const AUTOFILL_TOKEN_SHIPPING = \"shipping\";\n\nexport const AUTOFILL_TOKENS_ADDRESS = [AUTOFILL_TOKEN_BILLING, AUTOFILL_TOKEN_SHIPPING];\n\nexport const AUTOFILL_TOKEN_HOME = \"home\";\nexport const AUTOFILL_TOKEN_WORK = \"work\";\nexport const AUTOFILL_TOKEN_MOBILE = \"mobile\";\nexport const AUTOFILL_TOKEN_FAX = \"fax\";\nexport const AUTOFILL_TOKEN_PAGER = \"pager\";\n\nexport const AUTOFILL_TOKENS_CONTACT = [\n    AUTOFILL_TOKEN_FAX, AUTOFILL_TOKEN_HOME, AUTOFILL_TOKEN_MOBILE, AUTOFILL_TOKEN_PAGER, AUTOFILL_TOKEN_WORK\n];\n\nexport const AUTOFILL_FIELD_STREET_ADDRESS = \"street-address\";\nexport const AUTOFILL_FIELD_ADDRESS_LINE_1 = \"address-line1\";\nexport const AUTOFILL_FIELD_ADDRESS_LINE_2 = \"address-line2\";\nexport const AUTOFILL_FIELD_ADDRESS_LINE_3 = \"address-line3\";\nexport const AUTOFILL_FIELD_ADDRESS_LEVEL_4 = \"address-level4\";\nexport const AUTOFILL_FIELD_ADDRESS_LEVEL_3 = \"address-level3\";\nexport const AUTOFILL_FIELD_ADDRESS_LEVEL_2 = \"address-level2\";\nexport const AUTOFILL_FIELD_ADDRESS_LEVEL_1 = \"address-level1\";\n\nexport const AUTOFILL_FIELD_NAME = \"name\";\nexport const AUTOFILL_FIELD_HONORIFIC_PREFIX = \"honorific-prefix\";\nexport const AUTOFILL_FIELD_GIVEN_NAME = \"given-name\";\nexport const AUTOFILL_FIELD_ADDITIONAL_NAME = \"additional-name\";\nexport const AUTOFILL_FIELD_FAMILY_NAME = \"family-name\";\nexport const AUTOFILL_FIELD_HONORIFIC_SUFFIX = \"honorific-suffix\";\nexport const AUTOFILL_FIELD_NICKNAME = \"nickname\";\nexport const AUTOFILL_FIELD_USERNAME = \"username\";\n\nexport const AUTOFILL_FIELD_NEW_PASSWORD = \"new-password\";\nexport const AUTOFILL_FIELD_CURRENT_PASSWORD = \"current-password\";\n\nexport const AUTOFILL_FIELD_ORGANIZATION_TITLE = \"organization-title\";\nexport const AUTOFILL_FIELD_ORGANIZATION = \"organization\";\n\nexport const AUTOFILL_FIELD_COUNTRY = \"country\";\nexport const AUTOFILL_FIELD_COUNTRY_NAME = \"country-name\";\nexport const AUTOFILL_FIELD_POSTAL_CODE = \"postal-code\";\n\nexport const AUTOFILL_FIELD_CC_NAME = \"cc-name\";\nexport const AUTOFILL_FIELD_CC_GIVEN_NAME = \"cc-given-name\";\nexport const AUTOFILL_FIELD_CC_ADDITIONAL_NAME = \"cc-additional-name\";\nexport const AUTOFILL_FIELD_CC_FAMILY_NAME = \"cc-family-name\";\nexport const AUTOFILL_FIELD_CC_NUMBER = \"cc-number\";\nexport const AUTOFILL_FIELD_CC_EXP = \"cc-exp\";\nexport const AUTOFILL_FIELD_CC_EXP_MONTH = \"cc-exp-month\";\nexport const AUTOFILL_FIELD_CC_EXP_YEAR = \"cc-exp-year\";\nexport const AUTOFILL_FIELD_CC_CSC = \"cc-csc\";\nexport const AUTOFILL_FIELD_CC_TYPE = \"cc-type\";\n\nexport const AUTOFILL_FIELD_TRANSACTION_CURRENCY = \"transaction-currency\";\nexport const AUTOFILL_FIELD_TRANSACTION_AMOUNT = \"transaction-amount\";\n\nexport const AUTOFILL_FIELD_LANGUAGE = \"language\";\n\nexport const AUTOFILL_FIELD_BDAY = \"bday\";\nexport const AUTOFILL_FIELD_BDAY_DAY = \"bday-day\";\nexport const AUTOFILL_FIELD_BDAY_MONTH = \"bday-month\";\nexport const AUTOFILL_FIELD_BDAY_YEAR = \"bday-year\";\n\nexport const AUTOFILL_FIELD_SEX = \"sex\";\n\nexport const AUTOFILL_FIELD_URL = \"url\";\n\nexport const AUTOFILL_FIELD_PHOTO = \"photo\";\n\nexport const AUTOFILL_FIELDS = [\n\n    AUTOFILL_FIELD_STREET_ADDRESS, AUTOFILL_FIELD_ADDRESS_LINE_1, AUTOFILL_FIELD_ADDRESS_LINE_2,\n    AUTOFILL_FIELD_ADDRESS_LINE_3, AUTOFILL_FIELD_ADDRESS_LEVEL_4, AUTOFILL_FIELD_ADDRESS_LEVEL_3,\n    AUTOFILL_FIELD_ADDRESS_LEVEL_2, AUTOFILL_FIELD_ADDRESS_LEVEL_1, AUTOFILL_FIELD_NAME,\n    AUTOFILL_FIELD_HONORIFIC_PREFIX, AUTOFILL_FIELD_GIVEN_NAME, AUTOFILL_FIELD_ADDITIONAL_NAME,\n    AUTOFILL_FIELD_FAMILY_NAME, AUTOFILL_FIELD_HONORIFIC_SUFFIX, AUTOFILL_FIELD_NICKNAME, AUTOFILL_FIELD_USERNAME,\n    AUTOFILL_FIELD_NEW_PASSWORD, AUTOFILL_FIELD_CURRENT_PASSWORD, AUTOFILL_FIELD_ORGANIZATION_TITLE,\n    AUTOFILL_FIELD_ORGANIZATION, AUTOFILL_FIELD_COUNTRY, AUTOFILL_FIELD_COUNTRY_NAME, AUTOFILL_FIELD_POSTAL_CODE,\n    AUTOFILL_FIELD_CC_NAME, AUTOFILL_FIELD_CC_GIVEN_NAME, AUTOFILL_FIELD_CC_ADDITIONAL_NAME,\n    AUTOFILL_FIELD_CC_FAMILY_NAME, AUTOFILL_FIELD_CC_NUMBER, AUTOFILL_FIELD_CC_EXP, AUTOFILL_FIELD_CC_EXP_MONTH,\n    AUTOFILL_FIELD_CC_EXP_YEAR, AUTOFILL_FIELD_CC_CSC, AUTOFILL_FIELD_CC_TYPE, AUTOFILL_FIELD_TRANSACTION_CURRENCY,\n    AUTOFILL_FIELD_TRANSACTION_AMOUNT, AUTOFILL_FIELD_LANGUAGE, AUTOFILL_FIELD_BDAY, AUTOFILL_FIELD_BDAY_DAY,\n    AUTOFILL_FIELD_BDAY_MONTH, AUTOFILL_FIELD_BDAY_YEAR, AUTOFILL_FIELD_SEX, AUTOFILL_FIELD_URL, AUTOFILL_FIELD_PHOTO\n];\n\nexport const AUTOFILL_FIELD_TEL = \"tel\";\nexport const AUTOFILL_FIELD_TEL_COUNTRY_CODE = \"tel-country-code\";\nexport const AUTOFILL_FIELD_TEL_NATIONAL = \"tel-national\";\nexport const AUTOFILL_FIELD_TEL_AREA_CODE = \"tel-area-code\";\nexport const AUTOFILL_FIELD_TEL_LOCAL = \"tel-local\";\nexport const AUTOFILL_FIELD_TEL_LOCAL_PREFIX = \"tel-local-prefix\";\nexport const AUTOFILL_FIELD_TEL_LOCAL_SUFFIX = \"tel-local-suffix\";\nexport const AUTOFILL_FIELD_TEL_LOCAL_EXTENSION = \"tel-extension\";\nexport const AUTOFILL_FIELD_EMAIL = \"email\";\nexport const AUTOFILL_FIELD_IMPP = \"impp\";\n\nexport const AUTOFILL_FIELDS_CONTACT = [\n\n    AUTOFILL_FIELD_TEL, AUTOFILL_FIELD_TEL_COUNTRY_CODE, AUTOFILL_FIELD_TEL_NATIONAL, AUTOFILL_FIELD_TEL_AREA_CODE,\n    AUTOFILL_FIELD_TEL_LOCAL, AUTOFILL_FIELD_TEL_LOCAL_PREFIX, AUTOFILL_FIELD_TEL_LOCAL_SUFFIX,\n    AUTOFILL_FIELD_TEL_LOCAL_EXTENSION, AUTOFILL_FIELD_EMAIL, AUTOFILL_FIELD_IMPP\n];\n\nexport function isAddressToken(token: string): boolean {\n    return AUTOFILL_TOKENS_ADDRESS.indexOf(token) > -1;\n}\n\nexport function isContactField(token: string): boolean {\n    return AUTOFILL_FIELDS_CONTACT.indexOf(token) > -1;\n}\n\nexport function isContactToken(token: string): boolean {\n    return AUTOFILL_TOKENS_CONTACT.indexOf(token) > -1;\n}\n\nexport function isField(token: string): boolean {\n    return AUTOFILL_FIELDS.indexOf(token) > -1;\n}\n\nexport function isSectionToken(token: string): boolean {\n    return token.startsWith(\"section-\");\n}\n\nexport function validate(tokens: string): boolean {\n\n    let toExpression = (total: string, currentValue: string) => `${total}|${currentValue}`,\n        tokensAddress = AUTOFILL_TOKENS_ADDRESS.reduce(toExpression),\n        tokensContact = AUTOFILL_TOKENS_CONTACT.reduce(toExpression),\n        fields = AUTOFILL_FIELDS.reduce(toExpression),\n        fieldsContact = AUTOFILL_FIELDS_CONTACT.reduce(toExpression),\n        regex = new RegExp(`^(section-\\\\w+\\\\s{1})?((${tokensAddress}){1}\\\\s)?((${fields}){1}|((${tokensContact}){1}\\\\s{1}(${fieldsContact})))$`);\n\n    return regex.test(tokens);\n}\n","import { DynamicFormValueControlModel, DynamicFormValueControlModelConfig } from \"./dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../decorator/serializable.decorator\";\nimport { AUTOCOMPLETE_ON } from \"../utils/autofill.utils\";\nimport { isBoolean, isNumber } from \"../utils/core.utils\";\n\nexport interface DynamicInputControlModelConfig<T> extends DynamicFormValueControlModelConfig<T> {\n\n    autoComplete?: string;\n    autoFocus?: boolean;\n    maxLength?: number;\n    minLength?: number;\n    placeholder?: string;\n    prefix?: string;\n    readOnly?: boolean;\n    spellCheck?: boolean;\n    suffix?: string;\n}\n\nexport abstract class DynamicInputControlModel<T> extends DynamicFormValueControlModel<T> {\n\n    @serializable() autoComplete: string;\n    @serializable() autoFocus: boolean;\n    @serializable() maxLength: number | null;\n    @serializable() minLength: number | null;\n    @serializable() placeholder: string;\n    @serializable() prefix: string | null;\n    @serializable() readOnly: boolean;\n    @serializable() spellCheck: boolean;\n    @serializable() suffix: string | null;\n\n    protected constructor(config: DynamicInputControlModelConfig<T>, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.autoComplete = config.autoComplete || AUTOCOMPLETE_ON;\n        this.autoFocus = isBoolean(config.autoFocus) ? config.autoFocus : false;\n        this.maxLength = isNumber(config.maxLength) ? config.maxLength : null;\n        this.minLength = isNumber(config.minLength) ? config.minLength : null;\n        this.placeholder = config.placeholder || \"\";\n        this.prefix = config.prefix || null;\n        this.readOnly = isBoolean(config.readOnly) ? config.readOnly : false;\n        this.spellCheck = isBoolean(config.spellCheck) ? config.spellCheck : false;\n        this.suffix = config.suffix || null;\n    }\n}","import { isString } from \"./core.utils\";\n\nexport function maskToString(mask: string | RegExp | (string | RegExp)[]): string | string[] | null {\n\n    if (isString(mask)) {\n\n        return mask as string;\n\n    } else if (mask instanceof RegExp) {\n\n        return mask.toString();\n\n    } else if (Array.isArray(mask)) {\n\n        return mask.map(value => maskToString(value)) as string[];\n    }\n\n    return null;\n}\n\nexport function maskFromString(mask: string | string[]): string | RegExp | (string | RegExp)[] | null {\n\n    if (isString(mask)) {\n\n        let isRegExp = (mask as string).startsWith(\"/\") && (mask as string).endsWith(\"/\");\n\n        return isRegExp ? new RegExp((mask as string).slice(1, mask.length - 1)) : mask;\n\n    } else if (Array.isArray(mask)) {\n\n        return (mask as string[]).map(value => maskFromString(value)) as string[];\n    }\n\n    return null;\n}\n\nexport function parseReviver(_key: string, value: any): any {\n\n    let regexDateISO = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*))(?:Z|([+\\-])([\\d|:]*))?$/;\n\n    return isString(value) && regexDateISO.test(value) ? new Date(value) : value;\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, PartialObserver, TeardownLogic } from '../types';\nimport { noop } from '../util/noop';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function tap<T>(next?: (x: T) => void, error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(observer: PartialObserver<T>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * ![](do.png)\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `tap` is not subscribed, the side effects specified by the\n * Observer will never happen. `tap` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * ## Example\n * Map every click to the clientX position of that click, while also logging the click event\n * ```javascript\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(\n *   tap(ev => console.log(ev)),\n *   map(ev => ev.clientX),\n * );\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n * @see {@link Observable#subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nexport function tap<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n                       error?: (e: any) => void,\n                       complete?: () => void): MonoTypeOperatorFunction<T> {\n  return function tapOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\n\nclass DoOperator<T> implements Operator<T, T> {\n  constructor(private nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n              private error?: (e: any) => void,\n              private complete?: () => void) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nclass TapSubscriber<T> extends Subscriber<T> {\n  private _context: any;\n\n  private _tapNext: ((value: T) => void) = noop;\n\n  private _tapError: ((err: any) => void) = noop;\n\n  private _tapComplete: (() => void) = noop;\n\n  constructor(destination: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n      super(destination);\n      this._tapError = error || noop;\n      this._tapComplete = complete || noop;\n      if (isFunction(observerOrNext)) {\n        this._context = this;\n        this._tapNext = observerOrNext;\n      } else if (observerOrNext) {\n        this._context = observerOrNext;\n        this._tapNext = observerOrNext.next || noop;\n        this._tapError = observerOrNext.error || noop;\n        this._tapComplete = observerOrNext.complete || noop;\n      }\n    }\n\n  _next(value: T) {\n    try {\n      this._tapNext.call(this._context, value);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(value);\n  }\n\n  _error(err: any) {\n    try {\n      this._tapError.call(this._context, err);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.error(err);\n  }\n\n  _complete() {\n    try {\n      this._tapComplete.call(this._context, );\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    return this.destination.complete();\n  }\n}\n","import { DynamicInputControlModel, DynamicInputControlModelConfig } from \"../dynamic-input-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\nimport { maskToString } from \"../../utils/json.utils\";\nimport { isBoolean, isNumber } from \"../../utils/core.utils\";\nimport { Observable, isObservable, of } from \"rxjs\";\nimport { tap } from \"rxjs/operators\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_INPUT = \"INPUT\";\n\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_COLOR = \"color\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_DATE = \"date\";\n//export const DYNAMIC_FORM_CONTROL_INPUT_TYPE_DATETIME = \"datetime\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_DATETIME_LOCAL = \"datetime-local\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_EMAIL = \"email\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_FILE = \"file\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_MONTH = \"month\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_NUMBER = \"number\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_PASSWORD = \"password\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_RANGE = \"range\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_SEARCH = \"search\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_TEL = \"tel\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_TEXT = \"text\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_TIME = \"time\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_URL = \"url\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_WEEK = \"week\";\n\nexport interface DynamicInputModelConfig extends DynamicInputControlModelConfig<string | number | Date | string[]> {\n\n    accept?: string;\n    inputType?: string;\n    list?: any[] | Observable<any[]>;\n    mask?: string | RegExp | (string | RegExp)[];\n    max?: number | string | Date;\n    min?: number | string | Date;\n    multiple?: boolean;\n    pattern?: string;\n    step?: number;\n}\n\nexport class DynamicInputModel extends DynamicInputControlModel<string | number | Date | string[]> {\n\n    @serializable() accept: string | null;\n    @serializable() inputType: string;\n    files: FileList | null = null;\n    list$: Observable<any[]> | null = null;\n    @serializable() mask: string | RegExp | (string | RegExp)[] | null;\n    @serializable() max: number | string | Date | null;\n    @serializable() min: number | string | Date | null;\n    @serializable() multiple: boolean | null;\n    @serializable() pattern: string | null;\n    @serializable() step: number | null;\n\n    @serializable(\"list\") private _list: any[] | null = null;\n    private readonly _listId: string | null = null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_INPUT;\n\n    constructor(config: DynamicInputModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.accept = config.accept || null;\n        this.inputType = config.inputType || DYNAMIC_FORM_CONTROL_INPUT_TYPE_TEXT;\n        this.mask = config.mask || null;\n        this.max = config.max !== undefined ? config.max : null;\n        this.min = config.min !== undefined ? config.min : null;\n        this.multiple = isBoolean(config.multiple) ? config.multiple : null;\n        this.pattern = config.pattern || null;\n        this.step = isNumber(config.step) ? config.step : null;\n\n        if (config.list !== undefined) {\n\n            this.list = config.list;\n            this._listId = `${this.id}List`;\n        }\n    }\n\n    get listId(): string | null {\n        return this._listId;\n    }\n\n    get hasList(): boolean {\n        return isObservable(this.list$);\n    }\n\n    set list(list: any[] | Observable<any[]> | null) {\n\n        if (Array.isArray(list)) {\n\n            this._list = list;\n            this.list$ = of(this._list);\n\n        } else if (isObservable(list)) {\n\n            this.list$ = (list as Observable<any[]>).pipe(tap(list => this._list = list));\n\n        } else {\n\n            this._list = null;\n            this.list$ = null;\n        }\n    }\n\n    toJSON() {\n\n        let json: any = super.toJSON();\n\n        if (this.mask !== null) { json.mask = maskToString(this.mask); }\n\n        return json;\n    }\n}\n","export const DYNAMIC_FORM_CONTROL_ACTION_DISABLE = \"DISABLE\";\nexport const DYNAMIC_FORM_CONTROL_ACTION_ENABLE = \"ENABLE\";\nexport const DYNAMIC_FORM_CONTROL_ACTION_VISIBLE = \"VISIBLE\";\nexport const DYNAMIC_FORM_CONTROL_ACTION_HIDDEN = \"HIDDEN\";\n\nexport const DYNAMIC_FORM_CONTROL_CONNECTIVE_AND = \"AND\";\nexport const DYNAMIC_FORM_CONTROL_CONNECTIVE_OR = \"OR\";\n\nexport interface DynamicFormControlRelation {\n\n    id: string;\n    status?: string;\n    value?: any;\n}\n\nexport interface DynamicFormControlRelationGroup {\n\n    action: string;\n    connective?: string;\n    when: DynamicFormControlRelation[];\n}","import { FormGroup, FormControl } from \"@angular/forms\";\nimport { DynamicFormControlModel } from \"../model/dynamic-form-control.model\";\nimport {\n    DynamicFormControlRelation,\n    DynamicFormControlRelationGroup,\n    DYNAMIC_FORM_CONTROL_ACTION_DISABLE,\n    DYNAMIC_FORM_CONTROL_ACTION_ENABLE,\n    DYNAMIC_FORM_CONTROL_CONNECTIVE_AND,\n    DYNAMIC_FORM_CONTROL_CONNECTIVE_OR\n} from \"../model/misc/dynamic-form-control-relation.model\";\n\nexport function findActivationRelation(relGroups: DynamicFormControlRelationGroup[]): DynamicFormControlRelationGroup | null {\n\n    let rel = relGroups.find(rel => {\n        return rel.action === DYNAMIC_FORM_CONTROL_ACTION_DISABLE || rel.action === DYNAMIC_FORM_CONTROL_ACTION_ENABLE;\n    });\n\n    return rel !== undefined ? rel : null;\n}\n\nexport function getRelatedFormControls(model: DynamicFormControlModel, controlGroup: FormGroup): FormControl[] {\n\n    let controls: FormControl[] = [];\n\n    model.relation.forEach(relGroup => relGroup.when.forEach(rel => {\n\n        if (model.id === rel.id) {\n            throw new Error(`FormControl ${model.id} cannot depend on itself`);\n        }\n\n        let control = controlGroup.get(rel.id) as FormControl;\n\n        if (control && !controls.some(controlElement => controlElement === control)) {\n            controls.push(control);\n        }\n    }));\n\n    return controls;\n}\n\nexport function isFormControlToBeDisabled(relGroup: DynamicFormControlRelationGroup, _formGroup: FormGroup): boolean {\n\n    let formGroup: FormGroup = _formGroup;\n\n    return relGroup.when.reduce((toBeDisabled: boolean, rel: DynamicFormControlRelation, index: number) => {\n\n        let control = formGroup.get(rel.id);\n\n        if (control && relGroup.action === DYNAMIC_FORM_CONTROL_ACTION_DISABLE) {\n\n            if (index > 0 && relGroup.connective === DYNAMIC_FORM_CONTROL_CONNECTIVE_AND && !toBeDisabled) {\n                return false;\n            }\n\n            if (index > 0 && relGroup.connective === DYNAMIC_FORM_CONTROL_CONNECTIVE_OR && toBeDisabled) {\n                return true;\n            }\n\n            return rel.value === control.value || rel.status === control.status;\n        }\n\n        if (control && relGroup.action === DYNAMIC_FORM_CONTROL_ACTION_ENABLE) {\n\n            if (index > 0 && relGroup.connective === DYNAMIC_FORM_CONTROL_CONNECTIVE_AND && toBeDisabled) {\n                return true;\n            }\n\n            if (index > 0 && relGroup.connective === DYNAMIC_FORM_CONTROL_CONNECTIVE_OR && !toBeDisabled) {\n                return false;\n            }\n\n            return !(rel.value === control.value || rel.status === control.status);\n        }\n\n        return false;\n\n    }, false);\n}\n","import {\n    ComponentFactoryResolver,\n    ComponentRef,\n    EventEmitter,\n    OnChanges,\n    OnDestroy,\n    QueryList,\n    SimpleChange,\n    SimpleChanges,\n    Type,\n    ViewContainerRef\n} from \"@angular/core\";\nimport { FormControl, FormGroup } from \"@angular/forms\";\nimport { Subscription } from \"rxjs\";\nimport {\n    DynamicFormControlCustomEvent,\n    DynamicFormControlEvent,\n    DynamicFormControlEventType,\n    isDynamicFormControlEvent\n} from \"./dynamic-form-control.event\";\nimport { DynamicFormControlModel } from \"../model/dynamic-form-control.model\";\nimport { DynamicFormValueControlModel } from \"../model/dynamic-form-value-control.model\";\nimport {\n    DynamicFormArrayGroupModel,\n    DYNAMIC_FORM_CONTROL_TYPE_ARRAY\n} from \"../model/form-array/dynamic-form-array.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX } from \"../model/checkbox/dynamic-checkbox.model\";\nimport {\n    DynamicInputModel,\n    DYNAMIC_FORM_CONTROL_TYPE_INPUT,\n    DYNAMIC_FORM_CONTROL_INPUT_TYPE_FILE\n} from \"../model/input/dynamic-input.model\";\nimport {\n    DynamicFormControlLayout,\n    DynamicFormControlLayoutContext,\n    DynamicFormControlLayoutPlace\n} from \"../model/misc/dynamic-form-control-layout.model\";\nimport { DynamicFormControlRelationGroup } from \"../model/misc/dynamic-form-control-relation.model\";\nimport { DynamicTemplateDirective } from \"../directive/dynamic-template.directive\";\nimport { DynamicFormLayout, DynamicFormLayoutService } from \"../service/dynamic-form-layout.service\";\nimport { DynamicFormValidationService } from \"../service/dynamic-form-validation.service\";\nimport { findActivationRelation, getRelatedFormControls, isFormControlToBeDisabled } from \"../utils/relation.utils\";\nimport { DynamicFormControl } from \"./dynamic-form-control.interface\";\nimport { isString } from \"../utils/core.utils\";\n\nexport abstract class DynamicFormControlContainerComponent implements OnChanges, OnDestroy {\n\n    context: DynamicFormArrayGroupModel | null = null;\n    control: FormControl;\n    group: FormGroup;\n    hasFocus: boolean;\n    layout: DynamicFormLayout;\n    model: DynamicFormControlModel;\n\n    contentTemplateList: QueryList<DynamicTemplateDirective> | undefined;\n    inputTemplateList: QueryList<DynamicTemplateDirective> | undefined;\n\n    blur: EventEmitter<DynamicFormControlEvent>;\n    change: EventEmitter<DynamicFormControlEvent>;\n    customEvent: EventEmitter<DynamicFormControlEvent> | undefined;\n    focus: EventEmitter<DynamicFormControlEvent>;\n\n    componentViewContainerRef: ViewContainerRef;\n\n    protected componentRef: ComponentRef<DynamicFormControl>;\n    //protected viewRefs: EmbeddedViewRef<DynamicFormControlModel>[] = [];\n    protected componentSubscriptions: Subscription[] = [];\n    protected subscriptions: Subscription[] = [];\n\n    protected constructor(protected componentFactoryResolver: ComponentFactoryResolver,\n                          protected layoutService: DynamicFormLayoutService,\n                          protected validationService: DynamicFormValidationService) { }\n\n    ngOnChanges(changes: SimpleChanges) {\n\n        let groupChange = changes[\"group\"] as SimpleChange,\n            modelChange = changes[\"model\"] as SimpleChange;\n\n        if (modelChange) {\n\n            this.destroyFormControlComponent();\n            //this.removeTemplates();\n\n            this.createFormControlComponent();\n            //this.embedTemplates();\n        }\n\n        if (groupChange || modelChange) {\n\n            if (this.model) {\n\n                this.unsubscribe();\n\n                if (this.group) {\n\n                    this.control = this.group.get(this.model.id) as FormControl;\n                    this.subscriptions.push(this.control.valueChanges.subscribe(value => this.onControlValueChanges(value)));\n                }\n\n                this.subscriptions.push(this.model.disabledUpdates.subscribe(value => this.onModelDisabledUpdates(value)));\n\n                if (this.model instanceof DynamicFormValueControlModel) {\n\n                    let model = this.model as DynamicFormValueControlModel<any>;\n\n                    this.subscriptions.push(model.valueUpdates.subscribe(value => this.onModelValueUpdates(value)));\n                }\n\n                if (this.model.relation.length > 0) {\n                    this.setControlRelations();\n                }\n            }\n        }\n    }\n\n    ngOnDestroy() {\n\n        this.destroyFormControlComponent();\n        this.unsubscribe();\n    }\n\n    abstract get componentType(): Type<DynamicFormControl> | null;\n\n    get errorMessages(): string[] {\n        return this.validationService.createErrorMessages(this.control, this.model);\n    }\n\n    get hasHint(): boolean {\n        return isString((this.model as DynamicFormValueControlModel<any>).hint);\n    }\n\n    get hasLabel(): boolean {\n        return isString(this.model.label);\n    }\n\n    get isCheckbox(): boolean {\n        return this.model.type === DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX;\n    }\n\n    get elementId(): string {\n        return this.layoutService.getElementId(this.model);\n    }\n\n    get isInvalid(): boolean {\n        return this.control.invalid;\n    }\n\n    get isValid(): boolean {\n        return this.control.valid;\n    }\n\n    get showErrorMessages(): boolean {\n        return this.model.hasErrorMessages && this.control.touched && !this.hasFocus && this.isInvalid;\n    }\n\n    get templates(): QueryList<DynamicTemplateDirective> | undefined {\n        return this.inputTemplateList !== undefined ? this.inputTemplateList : this.contentTemplateList;\n    }\n\n    get startTemplate(): DynamicTemplateDirective | undefined {\n        return this.model.type !== DYNAMIC_FORM_CONTROL_TYPE_ARRAY ?\n            this.layoutService.getStartTemplate(this.model, this.templates) : undefined;\n    }\n\n    get endTemplate(): DynamicTemplateDirective | undefined {\n        return this.model.type !== DYNAMIC_FORM_CONTROL_TYPE_ARRAY ?\n            this.layoutService.getEndTemplate(this.model, this.templates) : undefined;\n    }\n\n    getClass(context: DynamicFormControlLayoutContext, place: DynamicFormControlLayoutPlace, model: DynamicFormControlModel = this.model): string {\n\n        let controlLayout = (this.layout && this.layout[model.id]) || model.layout as DynamicFormControlLayout;\n\n        return this.layoutService.getClass(controlLayout, context, place);\n    }\n\n    protected createFormControlComponent(): void {\n\n        let componentType = this.componentType;\n\n        if (componentType !== null) {\n\n            let componentFactory = this.componentFactoryResolver.resolveComponentFactory(componentType);\n\n            this.componentViewContainerRef.clear();\n            this.componentRef = this.componentViewContainerRef.createComponent(componentFactory);\n\n            let instance = this.componentRef.instance;\n\n            instance.group = this.group;\n            instance.layout = this.layout;\n            instance.model = this.model as any;\n\n            if (this.templates) {\n                instance.templates = this.templates;\n            }\n\n            this.componentSubscriptions.push(instance.blur.subscribe(($event: any) => this.onBlur($event)));\n            this.componentSubscriptions.push(instance.change.subscribe(($event: any) => this.onChange($event)));\n            this.componentSubscriptions.push(instance.focus.subscribe(($event: any) => this.onFocus($event)));\n\n            if (instance.customEvent !== undefined) {\n                this.componentSubscriptions.push(\n                    instance.customEvent.subscribe(($event: any) => this.onCustomEvent($event)));\n            }\n        }\n    }\n\n    protected destroyFormControlComponent(): void {\n\n        if (this.componentRef) {\n\n            this.componentSubscriptions.forEach(subscription => subscription.unsubscribe());\n            this.componentSubscriptions = [];\n\n            this.componentRef.destroy();\n        }\n    }\n    /*\n    protected embedTemplates(): void {\n\n        const templates = this.layoutService.getIndexedTemplates(this.model, this.templates);\n\n        if (Array.isArray(templates)) {\n\n            templates.forEach(template => {\n\n                const viewRef = this.componentViewContainerRef.createEmbeddedView(template.templateRef, this.model, template.index);\n                this.viewRefs.push(viewRef);\n            });\n        }\n    }\n\n    protected removeTemplates(): void {\n        this.viewRefs.forEach(viewRef => this.componentViewContainerRef.remove(this.componentViewContainerRef.indexOf(viewRef)));\n    }\n    */\n    protected setControlRelations(): void {\n\n        let relActivation = findActivationRelation(this.model.relation);\n\n        if (relActivation !== null) {\n\n            let rel = relActivation as DynamicFormControlRelationGroup;\n\n            this.updateModelDisabled(rel);\n\n            getRelatedFormControls(this.model, this.group).forEach(control => {\n\n                this.subscriptions.push(control.valueChanges.subscribe(() => this.updateModelDisabled(rel)));\n                this.subscriptions.push(control.statusChanges.subscribe(() => this.updateModelDisabled(rel)));\n            });\n        }\n    }\n\n    protected createDynamicFormControlEvent($event: any, type: string): DynamicFormControlEvent {\n        return {$event, context: this.context, control: this.control, group: this.group, model: this.model, type};\n    }\n\n    updateModelDisabled(relation: DynamicFormControlRelationGroup): void {\n\n        this.model.disabledUpdates.next(isFormControlToBeDisabled(relation, this.group));\n    }\n\n    unsubscribe(): void {\n\n        this.subscriptions.forEach(subscription => subscription.unsubscribe());\n        this.subscriptions = [];\n    }\n\n    onControlValueChanges(value: any): void {\n\n        if (this.model instanceof DynamicFormValueControlModel) {\n\n            let model = this.model as DynamicFormValueControlModel<any>;\n\n            if (model.value !== value) {\n                model.valueUpdates.next(value);\n            }\n        }\n    }\n\n    onModelValueUpdates(value: any): void {\n\n        if (this.control.value !== value) {\n            this.control.setValue(value);\n        }\n    }\n\n    onModelDisabledUpdates(value: boolean): void {\n        value ? this.control.disable() : this.control.enable();\n    }\n\n    onChange($event: Event | DynamicFormControlEvent | any): void {\n\n        if ($event && $event instanceof Event) { // native HTML5 change event\n\n            if (this.model.type === DYNAMIC_FORM_CONTROL_TYPE_INPUT) {\n\n                let model = this.model as DynamicInputModel;\n\n                if (model.inputType === DYNAMIC_FORM_CONTROL_INPUT_TYPE_FILE) {\n\n                    let inputElement: any = $event.target || $event.srcElement;\n\n                    model.files = inputElement.files as FileList;\n                }\n            }\n\n            this.change.emit(this.createDynamicFormControlEvent($event, DynamicFormControlEventType.Change));\n\n        } else if (isDynamicFormControlEvent($event)) { // event bypass\n\n            this.change.emit($event);\n\n        } else { // custom library value change event\n\n            this.change.emit(this.createDynamicFormControlEvent($event, DynamicFormControlEventType.Change));\n        }\n    }\n\n    onBlur($event: FocusEvent | DynamicFormControlEvent | any): void {\n\n        if (isDynamicFormControlEvent($event)) { // event bypass\n\n            this.blur.emit($event);\n\n        } else { // native HTML 5 or UI library blur event\n\n            this.hasFocus = false;\n            this.blur.emit(this.createDynamicFormControlEvent($event, DynamicFormControlEventType.Blur));\n        }\n    }\n\n    onFocus($event: FocusEvent | DynamicFormControlEvent | any): void {\n\n        if (isDynamicFormControlEvent($event)) { // event bypass\n\n            this.focus.emit($event);\n\n        } else { // native HTML 5 or UI library focus event\n\n            this.hasFocus = true;\n            this.focus.emit(this.createDynamicFormControlEvent($event, DynamicFormControlEventType.Focus));\n        }\n    }\n\n    onCustomEvent($event: DynamicFormControlEvent | DynamicFormControlCustomEvent): void {\n\n        let emitter = this.customEvent as EventEmitter<DynamicFormControlEvent>;\n\n        if (isDynamicFormControlEvent($event)) { // child event bypass\n\n            emitter.emit($event);\n\n        } else { // native UI library custom event\n\n            emitter.emit(this.createDynamicFormControlEvent($event.customEvent, $event.customEventType));\n        }\n    }\n}\n","import { AfterViewInit, QueryList, TemplateRef } from \"@angular/core\";\nimport { DynamicTemplateableFormControl } from \"./dynamic-templateable-form-control.interface\";\nimport { DynamicTemplateDirective } from \"../directive/dynamic-template.directive\";\nimport { DynamicFormControlComponent } from \"./dynamic-form-control.component\";\nimport { isString } from \"../utils/core.utils\";\n\nexport abstract class DynamicTemplateableFormControlComponent extends DynamicFormControlComponent implements DynamicTemplateableFormControl, AfterViewInit {\n\n    readonly templateDirectives: Map<string, string>;\n\n    templates: QueryList<DynamicTemplateDirective> | DynamicTemplateDirective[] | undefined;\n\n    ngAfterViewInit() {\n\n        this.layoutService\n            .filterTemplatesByModel(this.model, this.templates)\n            .forEach(template => this.bindTemplate(template));\n    }\n\n    abstract get viewChild(): any;\n\n    abstract mapTemplate(template: DynamicTemplateDirective): DynamicTemplateDirective | TemplateRef<any>;\n\n    bindTemplate(template: DynamicTemplateDirective) {\n\n        if (isString(template.as) && this.templateDirectives.has(template.as)) {\n\n            let property = this.templateDirectives.get(template.as) as string;\n\n            this.viewChild[property] = this.mapTemplate(template);\n        }\n    }\n}","import { Directive, ElementRef, Input, Renderer2, AfterViewInit } from \"@angular/core\";\n\n@Directive({\n    selector: \"[dynamicId]\"\n})\nexport class DynamicIdDirective implements AfterViewInit {\n\n    @Input() dynamicId: string | boolean;\n\n    constructor(private elementRef: ElementRef, private renderer: Renderer2) {}\n\n    ngAfterViewInit() {\n\n        if (this.dynamicId) {\n            this.renderer.setAttribute(this.elementRef.nativeElement, \"id\", this.dynamicId as string);\n        }\n    }\n}","import { Directive, ElementRef, Input, Renderer2, AfterViewInit } from \"@angular/core\";\nimport { isString } from \"../utils/core.utils\";\n\n@Directive({\n    selector: \"[dynamicList]\"\n})\nexport class DynamicListDirective implements AfterViewInit {\n\n    @Input(\"dynamicList\") listId: string | null;\n\n    constructor(private elementRef: ElementRef, private renderer: Renderer2) {}\n\n    ngAfterViewInit() {\n\n        if (isString(this.listId)) {\n            this.renderer.setAttribute(this.elementRef.nativeElement, \"list\", this.listId as string);\n        }\n    }\n}","import { Directive, Input, TemplateRef } from \"@angular/core\";\n\nexport enum DYNAMIC_TEMPLATE_DIRECTIVE_ALIGNMENT { Start = \"START\", End = \"END\"}\n\n@Directive({\n    selector: \"ng-template[modelId],ng-template[modelType]\"\n})\nexport class DynamicTemplateDirective {\n\n    @Input() align: string = DYNAMIC_TEMPLATE_DIRECTIVE_ALIGNMENT.End;\n    @Input() as: string | null = null;\n    @Input() index: number | undefined;\n    @Input() modelId: string;\n    @Input() modelType: string;\n\n    constructor(public templateRef: TemplateRef<any>) {}\n}\n","import { DynamicFormValueControlModelConfig, DynamicFormValueControlModel } from \"./dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../decorator/serializable.decorator\";\n\nexport type DynamicDateControlValue = string | object | Date;\n\nexport interface DynamicDateControlModelConfig extends DynamicFormValueControlModelConfig<DynamicDateControlValue> {\n\n    format?: string;\n    max?: DynamicDateControlValue;\n    min?: DynamicDateControlValue;\n    placeholder?: string;\n}\n\nexport abstract class DynamicDateControlModel extends DynamicFormValueControlModel<DynamicDateControlValue> {\n\n    @serializable() format: string | null;\n    @serializable() max: DynamicDateControlValue | null;\n    @serializable() min: DynamicDateControlValue | null;\n    @serializable() placeholder: string | null;\n\n    protected constructor(config: DynamicDateControlModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.format = config.format || null;\n        this.max = config.max || null;\n        this.min = config.min || null;\n        this.placeholder = config.placeholder || null;\n    }\n}","import { DynamicFormValueControlModelConfig, DynamicFormValueControlModel } from \"./dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../decorator/serializable.decorator\";\nimport { isBoolean } from \"../utils/core.utils\";\n\nexport interface DynamicFileControlModelConfig extends DynamicFormValueControlModelConfig<File | File[]> {\n\n    multiple?: boolean;\n}\n\nexport abstract class DynamicFileControlModel extends DynamicFormValueControlModel<File | File[]> {\n\n    @serializable() multiple: boolean;\n\n    protected constructor(config: DynamicFileControlModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.multiple = isBoolean(config.multiple) ? config.multiple : false;\n    }\n}","import { Observable, isObservable, of } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { DynamicFormValueControlModel, DynamicFormValueControlModelConfig } from \"./dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { serializable, serialize } from \"../decorator/serializable.decorator\";\nimport { isBoolean } from \"../utils/core.utils\";\n\nexport interface DynamicFormOptionConfig<T> {\n\n    disabled?: boolean;\n    label?: string;\n    value: T;\n}\n\nexport class DynamicFormOption<T> {\n\n    @serializable() disabled: boolean;\n    @serializable() label: string | null;\n    @serializable() value: T;\n\n    constructor(config: DynamicFormOptionConfig<T>) {\n\n        this.disabled = isBoolean(config.disabled) ? config.disabled : false;\n        this.label = config.label || null;\n        this.value = config.value;\n    }\n\n    get text() {\n        return this.label;\n    }\n\n    set text(text: string | null) {\n        this.label = text;\n    }\n\n    toJSON() {\n        return serialize(this);\n    }\n}\n\nexport interface DynamicOptionControlModelConfig<T> extends DynamicFormValueControlModelConfig<T | T[]> {\n\n    options?: DynamicFormOptionConfig<T>[] | Observable<DynamicFormOptionConfig<T>[]>;\n}\n\nexport abstract class DynamicOptionControlModel<T> extends DynamicFormValueControlModel<T | T[]> {\n\n    @serializable(\"options\") private _options: DynamicFormOption<T>[] = [];\n    options$: Observable<DynamicFormOption<T>[]>;\n\n    protected constructor(config: DynamicOptionControlModelConfig<T>, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.options = config.options;\n    }\n\n    private updateOptions$(): void {\n        this.options$ = of(this.options);\n    }\n\n    set options(options: any) {\n\n        if (Array.isArray(options)) {\n\n            this._options = (options as DynamicFormOptionConfig<T>[]).map(optionConfig => {\n                return new DynamicFormOption<T>(optionConfig);\n            });\n\n            this.updateOptions$();\n\n        } else if (isObservable(options)) {\n\n            this.options$ = (options as Observable<DynamicFormOptionConfig<T>[]>).pipe(\n                map(optionsConfig => {\n\n                    let options = optionsConfig.map(optionConfig => new DynamicFormOption<T>(optionConfig));\n\n                    this._options = options;\n\n                    return options;\n                }));\n\n        } else {\n\n            this.updateOptions$();\n        }\n    }\n\n    get options(): any {\n        return this._options;\n    }\n\n    add(optionConfig: DynamicFormOptionConfig<T>): DynamicFormOption<T> {\n        return this.insert(this.options.length, optionConfig);\n    }\n\n    get(index: number): DynamicFormOption<T> {\n        return this.options[index];\n    }\n\n    insert(index: number, optionConfig: DynamicFormOptionConfig<T>): DynamicFormOption<T> {\n\n        let option = new DynamicFormOption(optionConfig);\n\n        this.options.splice(index, 0, option);\n        this.updateOptions$();\n\n        return option;\n    }\n\n    remove(...indices: number[]): void {\n\n        indices.forEach(index => this.options.splice(index, 1));\n        this.updateOptions$();\n    }\n\n    abstract select(...indices: number[]): void;\n}","import { DynamicFormControlModel, DynamicFormControlModelConfig } from \"../dynamic-form-control.model\";\nimport { DynamicFormModel } from \"../dynamic-form.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_GROUP = \"GROUP\";\n\nexport interface DynamicFormGroupModelConfig extends DynamicFormControlModelConfig {\n\n    group?: DynamicFormModel;\n    legend?: string;\n}\n\nexport class DynamicFormGroupModel extends DynamicFormControlModel {\n\n    @serializable() group: DynamicFormModel = [];\n    @serializable() legend: string | null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_GROUP;\n\n    constructor(config: DynamicFormGroupModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.group = Array.isArray(config.group) ? config.group : [];\n        this.legend = config.legend || null;\n    }\n\n    get(index: number): DynamicFormControlModel {\n        return this.group[index];\n    }\n\n    set(index: number, controlModel: DynamicFormControlModel,): void {\n        this.group[index] = controlModel;\n    }\n\n    add(controlModel: DynamicFormControlModel): void {\n        this.group.push(controlModel);\n    }\n\n    insert(index: number, controlModel: DynamicFormControlModel): void {\n        this.group.splice(index, 0, controlModel);\n    }\n\n    move(index: number, step: number): void {\n        this.group.splice(index + step, 0, ...this.group.splice(index, 1));\n    }\n\n    remove(index: number) {\n        this.group.splice(index, 1);\n    }\n\n    size(): number {\n        return this.group.length;\n    }\n}\n","import { DynamicFormGroupModel, DynamicFormGroupModelConfig } from \"../form-group/dynamic-form-group.model\";\nimport { DynamicCheckboxModel } from \"./dynamic-checkbox.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX_GROUP = \"CHECKBOX_GROUP\";\n\nexport class DynamicCheckboxGroupModel extends DynamicFormGroupModel {\n\n    @serializable() group: DynamicCheckboxModel[];\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX_GROUP;\n\n    constructor(config: DynamicFormGroupModelConfig, layout?: DynamicFormControlLayout) {\n        super(config, layout);\n    }\n\n    check(...indices: number[]): void {\n        indices.forEach(index => this.group[index].checked = true);\n    }\n\n    uncheck(...indices: number[]): void {\n        indices.forEach(index => this.group[index].checked = false);\n    }\n\n    checkAll(): void {\n        this.group.forEach(model => model.checked = true);\n    }\n\n    uncheckAll(): void {\n        this.group.forEach(model => model.checked = false);\n    }\n}","import { DynamicFormValueControlModelConfig, DynamicFormValueControlModel } from \"../dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\nimport { isBoolean, isString } from \"../../utils/core.utils\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_COLORPICKER = \"COLORPICKER\";\n\nexport interface DynamicColorPickerModelConfig extends DynamicFormValueControlModelConfig<string | object> {\n\n    format?: string;\n    inline?: boolean;\n}\n\nexport class DynamicColorPickerModel extends DynamicFormValueControlModel<string | object> {\n\n    @serializable() format: string | null;\n    @serializable() inline: boolean;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_COLORPICKER;\n\n    constructor(config: DynamicColorPickerModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.format = isString(config.format) ? config.format : null;\n        this.inline = isBoolean(config.inline) ? config.inline : false;\n    }\n}","import {\n    DynamicDateControlModel,\n    DynamicDateControlModelConfig,\n    DynamicDateControlValue\n} from \"../dynamic-date-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\nimport { isBoolean, isString } from \"../../utils/core.utils\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_DATEPICKER = \"DATEPICKER\";\n\nexport interface DynamicDatePickerModelConfig extends DynamicDateControlModelConfig {\n\n    autoFocus?: boolean;\n    focusedDate?: DynamicDateControlValue;\n    inline?: boolean;\n    prefix?: string;\n    readOnly?: boolean;\n    suffix?: string;\n    toggleIcon?: string;\n    toggleLabel?: string;\n}\n\nexport class DynamicDatePickerModel extends DynamicDateControlModel {\n\n    @serializable() autoFocus: boolean;\n    @serializable() focusedDate: DynamicDateControlValue | null;\n    @serializable() inline: boolean;\n    @serializable() prefix: string | null;\n    @serializable() readOnly: boolean;\n    @serializable() suffix: string | null;\n    @serializable() toggleIcon: string | null;\n    @serializable() toggleLabel: string | null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_DATEPICKER;\n\n    constructor(config: DynamicDatePickerModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.autoFocus = isBoolean(config.autoFocus) ? config.autoFocus : false;\n        this.focusedDate = config.focusedDate || null;\n        this.inline = isBoolean(config.inline) ? config.inline : false;\n        this.prefix = config.prefix || null;\n        this.readOnly = isBoolean(config.readOnly) ? config.readOnly : false;\n        this.toggleIcon = isString(config.toggleIcon) ? config.toggleIcon : null;\n        this.toggleLabel = isString(config.toggleLabel) ? config.toggleLabel : null;\n        this.suffix = config.suffix || null;\n    }\n}","import { DynamicInputControlModel, DynamicInputControlModelConfig } from \"../dynamic-input-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_EDITOR = \"EDITOR\";\n\nexport interface DynamicEditorModelConfig extends DynamicInputControlModelConfig<string> {\n}\n\nexport class DynamicEditorModel extends DynamicInputControlModel<string> {\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_EDITOR;\n\n    constructor(config: DynamicEditorModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n    }\n}","import { DynamicFileControlModelConfig, DynamicFileControlModel } from \"../dynamic-file-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\nimport { isBoolean, isNumber } from \"../../utils/core.utils\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_FILE_UPLOAD = \"FILE_UPLOAD\";\n\nexport interface DynamicFileUploadModelConfig extends DynamicFileControlModelConfig {\n\n    accept?: string[];\n    autoUpload?: boolean;\n    maxSize?: number;\n    minSize?: number;\n    removeUrl?: string;\n    showFileList?: boolean;\n    url?: string;\n}\n\nexport class DynamicFileUploadModel extends DynamicFileControlModel {\n\n    @serializable() accept: string[] | null;\n    @serializable() autoUpload: boolean;\n    @serializable() maxSize: number | null;\n    @serializable() minSize: number | null;\n    @serializable() removeUrl: string | null;\n    @serializable() showFileList: boolean;\n    @serializable() url: string | null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_FILE_UPLOAD;\n\n    constructor(config: DynamicFileUploadModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.accept = Array.isArray(config.accept) ? config.accept : null;\n        this.autoUpload = isBoolean(config.autoUpload) ? config.autoUpload : true;\n        this.maxSize = isNumber(config.maxSize) ? config.maxSize : null;\n        this.minSize = isNumber(config.minSize) ? config.minSize : null;\n        this.removeUrl = config.removeUrl || null;\n        this.showFileList = isBoolean(config.showFileList) ? config.showFileList : true;\n        this.url = config.url || null;\n    }\n}","import { DynamicOptionControlModel, DynamicOptionControlModelConfig } from \"../dynamic-option-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_RADIO_GROUP = \"RADIO_GROUP\";\n\nexport interface DynamicRadioGroupModelConfig<T> extends DynamicOptionControlModelConfig<T> {\n\n    legend?: string;\n}\n\nexport class DynamicRadioGroupModel<T> extends DynamicOptionControlModel<T> {\n\n    @serializable() legend: string | null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_RADIO_GROUP;\n\n    constructor(config: DynamicRadioGroupModelConfig<T>, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.legend = config.legend || null;\n    }\n\n    select(index: number): void {\n        this.valueUpdates.next(this.get(index).value);\n    }\n}","import { DynamicFormValueControlModelConfig, DynamicFormValueControlModel } from \"../dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\nimport { isNumber } from \"../../utils/core.utils\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_RATING = \"RATING\";\n\nexport interface DynamicRatingModelConfig extends DynamicFormValueControlModelConfig<number> {\n\n    max?: number;\n}\n\nexport class DynamicRatingModel extends DynamicFormValueControlModel<number> {\n\n    @serializable() max: number | null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_RATING;\n\n    constructor(config: DynamicRatingModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.max = isNumber(config.max) ? config.max : 10;\n    }\n}","import { looseIdentical as looseIdentical } from \"@angular/core\";\nimport { DynamicOptionControlModel, DynamicOptionControlModelConfig } from \"../dynamic-option-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\nimport { isBoolean, isFunction } from \"../../utils/core.utils\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_SELECT = \"SELECT\";\n\nexport interface DynamicSelectModelConfig<T> extends DynamicOptionControlModelConfig<T> {\n\n    compareWithFn?: (o1: any, o2: any) => boolean;\n    filterable?: boolean;\n    multiple?: boolean;\n    placeholder?: string;\n    prefix?: string;\n    suffix?: string;\n}\n\nexport class DynamicSelectModel<T> extends DynamicOptionControlModel<T> {\n\n    compareWithFn: (o1: any, o2: any) => boolean;\n    @serializable() filterable: boolean;\n    @serializable() multiple: boolean;\n    @serializable() placeholder: string;\n    @serializable() prefix: string | null;\n    @serializable() suffix: string | null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_SELECT;\n\n    constructor(config: DynamicSelectModelConfig<T>, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.compareWithFn = isFunction(config.compareWithFn) ? config.compareWithFn : looseIdentical;\n        this.filterable = isBoolean(config.filterable) ? config.filterable : false;\n        this.multiple = isBoolean(config.multiple) ? config.multiple : false;\n        this.placeholder = config.placeholder || \"\";\n        this.prefix = config.prefix || null;\n        this.suffix = config.suffix || null;\n    }\n\n    select(...indices: number[]): void {\n\n        let value = this.multiple ? indices.map(index => this.get(index).value) : this.get(indices[0]).value;\n\n        this.valueUpdates.next(value);\n    }\n}","import { DynamicFormValueControlModelConfig, DynamicFormValueControlModel } from \"../dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\nimport { isBoolean, isNumber } from \"../../utils/core.utils\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_SLIDER = \"SLIDER\";\n\nexport interface DynamicSliderModelConfig extends DynamicFormValueControlModelConfig<number> {\n\n    max?: number;\n    min?: number;\n    step?: number;\n    vertical?: boolean;\n}\n\nexport class DynamicSliderModel extends DynamicFormValueControlModel<number> {\n\n    @serializable() max: number | null;\n    @serializable() min: number | null;\n    @serializable() step: number | null;\n    @serializable() vertical: boolean;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_SLIDER;\n\n    constructor(config: DynamicSliderModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.max = isNumber(config.max) ? config.max : 10;\n        this.min = isNumber(config.min) ? config.min : 0;\n        this.step = isNumber(config.step) ? config.step : 1;\n        this.vertical = isBoolean(config.vertical) ? config.vertical : false;\n    }\n}","import { DynamicCheckControlModel, DynamicCheckControlModelConfig } from \"../dynamic-check-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_SWITCH = \"SWITCH\";\n\nexport interface DynamicSwitchModelConfig extends DynamicCheckControlModelConfig {\n\n    offLabel?: string;\n    onLabel?: string;\n}\n\nexport class DynamicSwitchModel extends DynamicCheckControlModel {\n\n    @serializable() offLabel: string | null;\n    @serializable() onLabel: string | null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_SWITCH;\n\n    constructor(config: DynamicSwitchModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.offLabel = config.offLabel || null;\n        this.onLabel = config.onLabel || null;\n    }\n}","import { DynamicInputControlModel, DynamicInputControlModelConfig } from \"../dynamic-input-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\nimport { isNumber } from \"../../utils/core.utils\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_TEXTAREA = \"TEXTAREA\";\n\nexport const DYNAMIC_FORM_TEXTAREA_WRAP_HARD = \"hard\";\nexport const DYNAMIC_FORM_TEXTAREA_WRAP_SOFT = \"soft\";\n\nexport interface DynamicTextAreaModelConfig extends DynamicInputControlModelConfig<string> {\n\n    cols?: number;\n    rows?: number;\n    wrap?: string;\n}\n\nexport class DynamicTextAreaModel extends DynamicInputControlModel<string> {\n\n    @serializable() cols: number;\n    @serializable() rows: number;\n    @serializable() wrap: string;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_TEXTAREA;\n\n    constructor(config: DynamicTextAreaModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.cols = isNumber(config.cols) ? config.cols : 20;\n        this.rows = isNumber(config.rows) ? config.rows : 2;\n        this.wrap = config.wrap || DYNAMIC_FORM_TEXTAREA_WRAP_SOFT;\n    }\n}","import { DynamicDateControlModel, DynamicDateControlModelConfig } from \"../dynamic-date-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\nimport { isBoolean } from \"../../utils/core.utils\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_TIMEPICKER = \"TIMEPICKER\";\n\nexport interface DynamicTimePickerModelConfig extends DynamicDateControlModelConfig {\n\n    meridian?: boolean;\n    showSeconds?: boolean;\n}\n\nexport class DynamicTimePickerModel extends DynamicDateControlModel {\n\n    @serializable() meridian: boolean;\n    @serializable() showSeconds: boolean;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_TIMEPICKER;\n\n    constructor(config: DynamicTimePickerModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.meridian = isBoolean(config.meridian) ? config.meridian : false;\n        this.showSeconds = isBoolean(config.showSeconds) ? config.showSeconds : false;\n    }\n}","import { InjectionToken, Injectable, Inject, Optional } from \"@angular/core\";\nimport {\n    AbstractControl,\n    AsyncValidatorFn,\n    ValidatorFn,\n    Validators,\n    NG_VALIDATORS,\n    NG_ASYNC_VALIDATORS\n} from \"@angular/forms\";\nimport { DynamicFormControlModel } from \"../model/dynamic-form-control.model\";\nimport {\n    DynamicValidatorDescriptor,\n    DynamicValidatorsConfig\n} from \"../model/misc/dynamic-form-control-validation.model\";\nimport { isObject, isString } from \"../utils/core.utils\";\n\nexport type Validator = ValidatorFn | AsyncValidatorFn;\n\nexport type ValidatorFactory = (args: any) => Validator;\n\nexport type ValidatorsToken = Validator[];\n\nexport type ValidatorsMap = Map<string, Validator | ValidatorFactory>;\n\nexport const DYNAMIC_VALIDATORS = new InjectionToken<ValidatorsMap>(\"DYNAMIC_VALIDATORS\");\n\n@Injectable({\n    providedIn: \"root\"\n})\nexport class DynamicFormValidationService {\n\n    constructor(@Optional() @Inject(NG_VALIDATORS) private NG_VALIDATORS: ValidatorFn[],\n                @Optional() @Inject(NG_ASYNC_VALIDATORS) private NG_ASYNC_VALIDATORS: AsyncValidatorFn[],\n                @Optional() @Inject(DYNAMIC_VALIDATORS) private DYNAMIC_VALIDATORS: Map<string, Validator | ValidatorFactory>) {}\n\n\n    private getValidatorFn(validatorName: string, validatorArgs: any = null,\n                           validatorsToken: ValidatorsToken = this.NG_VALIDATORS): Validator | never {\n\n        let validatorFn: ValidatorFactory | Validator | undefined;\n\n        if (Validators.hasOwnProperty(validatorName)) { // Built-in Angular Validators\n\n            validatorFn = (Validators as any)[validatorName];\n\n        } else { // Custom Validators\n\n            if (this.DYNAMIC_VALIDATORS && this.DYNAMIC_VALIDATORS.has(validatorName)) {\n                validatorFn = this.DYNAMIC_VALIDATORS.get(validatorName);\n\n            } else if (validatorsToken) {\n                validatorFn = validatorsToken.find(validatorFn => validatorFn.name === validatorName);\n            }\n        }\n\n        if (validatorFn === undefined) { // throw when no validator could be resolved\n            throw new Error(`validator \"${validatorName}\" is not provided via NG_VALIDATORS, NG_ASYNC_VALIDATORS or DYNAMIC_FORM_VALIDATORS`);\n        }\n\n        if (validatorArgs !== null) {\n            return (validatorFn as ValidatorFactory)(validatorArgs);\n        }\n\n        return validatorFn as Validator;\n    }\n\n\n    private getValidatorFns(validatorsConfig: DynamicValidatorsConfig,\n                            validatorsToken: ValidatorsToken = this.NG_VALIDATORS): Validator[] {\n\n        let validatorFns: Validator[] = [];\n\n        if (isObject(validatorsConfig)) {\n\n            validatorFns = Object.keys(validatorsConfig).map(validatorConfigKey => {\n\n                let validatorConfigValue = (validatorsConfig as DynamicValidatorsConfig)[validatorConfigKey];\n\n                if (this.isValidatorDescriptor(validatorConfigValue)) {\n\n                    let descriptor = validatorConfigValue as DynamicValidatorDescriptor;\n\n                    return this.getValidatorFn(descriptor.name, descriptor.args, validatorsToken);\n                }\n\n                return this.getValidatorFn(validatorConfigKey, validatorConfigValue, validatorsToken);\n            });\n        }\n\n        return validatorFns;\n    }\n\n\n    private parseErrorMessageConfig(template: string, model: DynamicFormControlModel, error: any = null): string {\n\n        return template.replace(/{{\\s*(.+?)\\s*}}/mg, (_match: string, expression: string) => {\n\n            let propertySource: any = model,\n                propertyName: string = expression;\n\n            if (expression.indexOf(\"validator.\") >= 0 && error) {\n\n                propertySource = error;\n                propertyName = expression.replace(\"validator.\", \"\");\n            }\n\n            return propertySource[propertyName] ? propertySource[propertyName] : null;\n        });\n    }\n\n\n    getValidator(validatorName: string, validatorArgs: any = null): ValidatorFn {\n        return this.getValidatorFn(validatorName, validatorArgs) as ValidatorFn;\n    }\n\n\n    getAsyncValidator(validatorName: string, validatorArgs: any = null): AsyncValidatorFn {\n        return this.getValidatorFn(validatorName, validatorArgs, this.NG_ASYNC_VALIDATORS) as AsyncValidatorFn;\n    }\n\n\n    getValidators(validatorsConfig: DynamicValidatorsConfig): ValidatorFn[] {\n        return this.getValidatorFns(validatorsConfig) as ValidatorFn[];\n    }\n\n\n    getAsyncValidators(asyncValidatorsConfig: DynamicValidatorsConfig): AsyncValidatorFn[] {\n        return this.getValidatorFns(asyncValidatorsConfig, this.NG_ASYNC_VALIDATORS) as AsyncValidatorFn[];\n    }\n\n\n    updateValidators(validatorsConfig: DynamicValidatorsConfig | null, control: AbstractControl,\n                     model: DynamicFormControlModel): void {\n\n        model.validators = validatorsConfig;\n\n        if (validatorsConfig === null) {\n\n            control.clearValidators();\n\n        } else {\n            control.setValidators(this.getValidators(validatorsConfig));\n        }\n    }\n\n\n    updateAsyncValidators(asyncValidatorsConfig: DynamicValidatorsConfig | null, control: AbstractControl,\n                          model: DynamicFormControlModel): void {\n\n        model.asyncValidators = asyncValidatorsConfig;\n\n        if (asyncValidatorsConfig === null) {\n\n            control.clearAsyncValidators();\n\n        } else {\n            control.setAsyncValidators(this.getAsyncValidators(asyncValidatorsConfig));\n        }\n    }\n\n\n    createErrorMessages(control: AbstractControl, model: DynamicFormControlModel): string[] {\n\n        let messages: string[] = [];\n\n        if (model.hasErrorMessages) {\n\n            let messagesConfig = model.errorMessages as DynamicValidatorsConfig;\n\n            Object.keys(control.errors || {}).forEach(validationErrorKey => {\n\n                let messageKey = validationErrorKey;\n\n                if (validationErrorKey === \"minlength\" || validationErrorKey === \"maxlength\") {\n                    messageKey = messageKey.replace(\"length\", \"Length\");\n                }\n\n                if (messagesConfig.hasOwnProperty(messageKey)) {\n\n                    let validationError = control.getError(validationErrorKey),\n                        messageTemplate = messagesConfig[messageKey] as string;\n\n                    messages.push(this.parseErrorMessageConfig(messageTemplate, model, validationError));\n                }\n            });\n        }\n\n        return messages;\n    }\n\n\n    isFormHook(value: any): boolean {\n        return isString(value) && [\"blur\", \"change\", \"submit\"].indexOf(value) !== -1;\n    }\n\n\n    isValidatorDescriptor(value: any): boolean {\n\n        if (isObject(value)) {\n            return value.hasOwnProperty(\"name\") && value.hasOwnProperty(\"args\");\n        }\n\n        return false;\n    }\n}\n","import { Injectable } from \"@angular/core\";\nimport { AbstractControl, FormArray, FormControl, FormGroup } from \"@angular/forms\";\nimport { AbstractControlOptions, FormHooks } from \"@angular/forms/src/model\";\nimport { DynamicFormControlModel } from \"../model/dynamic-form-control.model\";\nimport { DynamicFormValueControlModel } from \"../model/dynamic-form-value-control.model\";\nimport {\n    DynamicFormArrayModel,\n    DYNAMIC_FORM_CONTROL_TYPE_ARRAY,\n    DynamicFormArrayGroupModel\n} from \"../model/form-array/dynamic-form-array.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_GROUP, DynamicFormGroupModel } from \"../model/form-group/dynamic-form-group.model\";\nimport {\n    DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX_GROUP,\n    DynamicCheckboxGroupModel\n} from \"../model/checkbox/dynamic-checkbox-group.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX, DynamicCheckboxModel } from \"../model/checkbox/dynamic-checkbox.model\";\nimport {\n    DYNAMIC_FORM_CONTROL_TYPE_COLORPICKER,\n    DynamicColorPickerModel\n} from \"../model/colorpicker/dynamic-colorpicker.model\";\nimport {\n    DYNAMIC_FORM_CONTROL_TYPE_DATEPICKER,\n    DynamicDatePickerModel\n} from \"../model/datepicker/dynamic-datepicker.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_EDITOR, DynamicEditorModel } from \"../model/editor/dynamic-editor.model\";\nimport {\n    DYNAMIC_FORM_CONTROL_TYPE_FILE_UPLOAD,\n    DynamicFileUploadModel\n} from \"../model/file-upload/dynamic-file-upload.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_INPUT, DynamicInputModel } from \"../model/input/dynamic-input.model\";\nimport {\n    DYNAMIC_FORM_CONTROL_TYPE_RADIO_GROUP,\n    DynamicRadioGroupModel\n} from \"../model/radio/dynamic-radio-group.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_RATING, DynamicRatingModel } from \"../model/rating/dynamic-rating.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_SELECT, DynamicSelectModel } from \"../model/select/dynamic-select.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_SLIDER, DynamicSliderModel } from \"../model/slider/dynamic-slider.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_SWITCH, DynamicSwitchModel } from \"../model/switch/dynamic-switch.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_TEXTAREA, DynamicTextAreaModel } from \"../model/textarea/dynamic-textarea.model\";\nimport {\n    DYNAMIC_FORM_CONTROL_TYPE_TIMEPICKER,\n    DynamicTimePickerModel\n} from \"../model/timepicker/dynamic-timepicker.model\";\nimport { DynamicFormValidationService } from \"./dynamic-form-validation.service\";\nimport { DynamicFormModel, DynamicUnionFormModel } from \"../model/dynamic-form.model\";\nimport { DynamicPathable } from \"../model/misc/dynamic-form-control-path.model\";\nimport { DynamicValidatorsConfig } from \"../model/misc/dynamic-form-control-validation.model\";\nimport { maskFromString, parseReviver } from \"../utils/json.utils\";\nimport { isString } from \"../utils/core.utils\";\n\n@Injectable({\n    providedIn: \"root\"\n})\nexport class DynamicFormService {\n\n    constructor(private validationService: DynamicFormValidationService) {}\n\n\n    private createAbstractControlOptions(validatorsConfig: DynamicValidatorsConfig | null = null,\n                                         asyncValidatorsConfig: DynamicValidatorsConfig | null = null,\n                                         updateOn: FormHooks | null = null): AbstractControlOptions {\n\n        return {\n\n            asyncValidators: asyncValidatorsConfig !== null ? this.validationService.getAsyncValidators(asyncValidatorsConfig) : null,\n\n            validators: validatorsConfig !== null ? this.validationService.getValidators(validatorsConfig) : null,\n\n            updateOn: updateOn !== null && this.validationService.isFormHook(updateOn) ? updateOn : \"change\"\n        };\n    }\n\n\n    createFormArray(formArrayModel: DynamicFormArrayModel): FormArray {\n\n        let controls: AbstractControl[] = [],\n            options = this.createAbstractControlOptions(formArrayModel.validators, formArrayModel.asyncValidators,\n                formArrayModel.updateOn);\n\n        for (let index = 0; index < formArrayModel.size; index++) {\n\n            let groupModel = formArrayModel.get(index),\n                groupOptions = this.createAbstractControlOptions(formArrayModel.groupValidators,\n                    formArrayModel.groupAsyncValidators, formArrayModel.updateOn);\n\n            controls.push(this.createFormGroup(groupModel.group, groupOptions, groupModel));\n        }\n\n        return new FormArray(controls, options);\n    }\n\n\n    createFormGroup(formModel: DynamicFormModel, options: AbstractControlOptions | null = null,\n                    parent: DynamicPathable | null = null): FormGroup {\n\n        let controls: { [controlId: string]: AbstractControl; } = {};\n\n        formModel.forEach(model => {\n\n            model.parent = parent;\n\n            switch (model.type) {\n\n                case DYNAMIC_FORM_CONTROL_TYPE_ARRAY:\n\n                    controls[model.id] = this.createFormArray(model as DynamicFormArrayModel);\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_GROUP:\n                case DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX_GROUP:\n\n                    let groupModel = model as DynamicFormGroupModel,\n                        groupOptions = this.createAbstractControlOptions(groupModel.validators,\n                            groupModel.asyncValidators, groupModel.updateOn);\n\n                    controls[model.id] = this.createFormGroup(groupModel.group, groupOptions, groupModel);\n                    break;\n\n                default:\n\n                    let controlModel = model as DynamicFormValueControlModel<any>,\n                        controlState = {value: controlModel.value, disabled: controlModel.disabled},\n                        controlOptions = this.createAbstractControlOptions(controlModel.validators,\n                            controlModel.asyncValidators, controlModel.updateOn);\n\n                    controls[model.id] = new FormControl(controlState, controlOptions);\n            }\n        });\n\n        return new FormGroup(controls, options);\n    }\n\n\n    getPathSegment(model: DynamicPathable): string {\n\n        return model instanceof DynamicFormArrayGroupModel ? model.index.toString() : (model as DynamicFormControlModel).id;\n    }\n\n\n    getPath(model: DynamicPathable): string[] {\n\n        let path = [this.getPathSegment(model)],\n            parent = model.parent;\n\n        while (parent) {\n\n            path.unshift(this.getPathSegment(parent));\n            parent = parent.parent;\n        }\n\n        return path;\n    }\n\n\n    addFormGroupControl(formGroup: FormGroup, formModel: DynamicUnionFormModel, ...models: DynamicFormModel): void {\n\n        if (formModel instanceof DynamicFormGroupModel) {\n\n            this.insertFormGroupControl(formModel.size(), formGroup, formModel, ...models);\n\n        } else {\n\n            let _formModel = formModel as DynamicFormModel;\n            this.insertFormGroupControl(_formModel.length, formGroup, _formModel, ...models);\n        }\n    }\n\n\n    moveFormGroupControl(index: number, step: number, formModel: DynamicUnionFormModel): void {\n\n        if (formModel instanceof DynamicFormGroupModel) {\n\n            formModel.move(index, step);\n\n        } else {\n\n            let _formModel = formModel as DynamicFormModel;\n            _formModel.splice(index + step, 0, ..._formModel.splice(index, 1));\n        }\n    }\n\n\n    insertFormGroupControl(index: number, formGroup: FormGroup, formModel: DynamicUnionFormModel,\n                           ...models: DynamicFormModel): void {\n\n        let parent = formModel instanceof DynamicFormGroupModel ? formModel : null,\n            controls = this.createFormGroup(models, null, parent).controls;\n\n        Object.keys(controls).forEach((controlName, idx) => {\n\n            let controlModel = models[idx];\n\n            if (formModel instanceof DynamicFormGroupModel) {\n                formModel.insert(index, controlModel);\n\n            } else {\n                (formModel as DynamicFormModel).splice(index, 0, controlModel);\n            }\n\n            formGroup.addControl(controlName, controls[controlName]);\n        });\n    }\n\n\n    removeFormGroupControl(index: number, formGroup: FormGroup, formModel: DynamicUnionFormModel): void {\n\n        if (formModel instanceof DynamicFormGroupModel) {\n\n            formGroup.removeControl(formModel.get(index).id);\n            formModel.remove(index);\n\n        } else {\n\n            formGroup.removeControl(formModel[index].id);\n            (formModel as DynamicFormModel).splice(index, 1);\n        }\n    }\n\n\n    addFormArrayGroup(formArray: FormArray, formArrayModel: DynamicFormArrayModel): void {\n\n        let groupModel = formArrayModel.addGroup();\n\n        formArray.push(this.createFormGroup(groupModel.group, null, groupModel));\n    }\n\n\n    insertFormArrayGroup(index: number, formArray: FormArray, formArrayModel: DynamicFormArrayModel): void {\n\n        let groupModel = formArrayModel.insertGroup(index);\n\n        formArray.insert(index, this.createFormGroup(groupModel.group, null, groupModel));\n    }\n\n\n    moveFormArrayGroup(index: number, step: number, formArray: FormArray, formArrayModel: DynamicFormArrayModel): void {\n\n        let newIndex = index + step,\n            moveUp = step >= 0;\n\n        if ((index >= 0 && index < formArrayModel.size) && (newIndex >= 0 && newIndex < formArrayModel.size)) {\n\n            let movingGroups: AbstractControl[] = [];\n\n            for (let i = moveUp ? index : newIndex; i <= (moveUp ? newIndex : index); i++) {\n                movingGroups.push(formArray.at(i));\n            }\n\n            movingGroups.forEach((formControl, idx) => {\n\n                let position;\n\n                if (moveUp) {\n                    position = idx === 0 ? newIndex : index + idx - 1;\n\n                } else {\n                    position = idx === movingGroups.length - 1 ? newIndex : newIndex + idx + 1;\n                }\n\n                formArray.setControl(position, formControl);\n            });\n\n            formArrayModel.moveGroup(index, step);\n\n        } else {\n            throw new Error(`form array group cannot be moved due to index or new index being out of bounds`);\n        }\n    }\n\n\n    removeFormArrayGroup(index: number, formArray: FormArray, formArrayModel: DynamicFormArrayModel): void {\n\n        formArray.removeAt(index);\n        formArrayModel.removeGroup(index);\n    }\n\n\n    clearFormArray(formArray: FormArray, formArrayModel: DynamicFormArrayModel): void {\n\n        while (formArray.length > 0) {\n            this.removeFormArrayGroup(0, formArray, formArrayModel);\n        }\n    }\n\n\n    findById(id: string, formModel: DynamicFormModel): DynamicFormControlModel | null {\n\n        let result = null,\n            findByIdFn = (id: string, groupModel: DynamicFormModel): void => {\n\n                for (let controlModel of groupModel) {\n\n                    if (controlModel.id === id) {\n                        result = controlModel;\n                        break;\n                    }\n\n                    if (controlModel instanceof DynamicFormGroupModel) {\n                        findByIdFn(id, (controlModel as DynamicFormGroupModel).group);\n                    }\n                }\n            };\n\n        findByIdFn(id, formModel);\n\n        return result;\n    }\n\n\n    fromJSON(json: string | object[]): DynamicFormModel | never {\n\n        let formModelJSON = isString(json) ? JSON.parse(json, parseReviver) : json,\n            formModel: DynamicFormModel = [];\n\n        formModelJSON.forEach((model: any) => {\n\n            let layout = model.layout || null;\n\n            switch (model.type) {\n\n                case DYNAMIC_FORM_CONTROL_TYPE_ARRAY:\n                    let formArrayModel = model as DynamicFormArrayModel;\n\n                    if (Array.isArray(formArrayModel.groups)) {\n\n                        formArrayModel.groups.forEach((groupModel: DynamicFormArrayGroupModel) => {\n                            groupModel.group = this.fromJSON(groupModel.group) as DynamicFormModel;\n                        });\n                    }\n\n                    formArrayModel.groupFactory = () => {\n                        return this.fromJSON(formArrayModel.groupPrototype);\n                    };\n\n                    formModel.push(new DynamicFormArrayModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX:\n                    formModel.push(new DynamicCheckboxModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX_GROUP:\n                    model.group = this.fromJSON(model.group) as DynamicCheckboxModel[];\n                    formModel.push(new DynamicCheckboxGroupModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_COLORPICKER:\n                    formModel.push(new DynamicColorPickerModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_DATEPICKER:\n                    formModel.push(new DynamicDatePickerModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_EDITOR:\n                    formModel.push(new DynamicEditorModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_FILE_UPLOAD:\n                    model.value = null;\n                    formModel.push(new DynamicFileUploadModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_GROUP:\n                    model.group = this.fromJSON(model.group);\n                    formModel.push(new DynamicFormGroupModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_INPUT:\n                    let inputModel = model as DynamicInputModel;\n\n                    if (inputModel.mask !== null) {\n                        inputModel.mask = maskFromString(inputModel.mask as string);\n                    }\n\n                    formModel.push(new DynamicInputModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_RADIO_GROUP:\n                    formModel.push(new DynamicRadioGroupModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_RATING:\n                    formModel.push(new DynamicRatingModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_SELECT:\n                    formModel.push(new DynamicSelectModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_SLIDER:\n                    formModel.push(new DynamicSliderModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_SWITCH:\n                    formModel.push(new DynamicSwitchModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_TEXTAREA:\n                    formModel.push(new DynamicTextAreaModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_TIMEPICKER:\n                    formModel.push(new DynamicTimePickerModel(model, layout));\n                    break;\n\n                default:\n                    throw new Error(`unknown form control model type defined on JSON object with id \"${model.id}\"`);\n            }\n        });\n\n        return formModel;\n    }\n}\n","import { Inject, Injectable, InjectionToken, Optional, QueryList, Type } from \"@angular/core\";\nimport {\n    DynamicFormControlLayout,\n    DynamicFormControlLayoutConfig,\n    DynamicFormControlLayoutContext,\n    DynamicFormControlLayoutPlace\n} from \"../model/misc/dynamic-form-control-layout.model\";\nimport { DynamicFormControlModel } from \"../model/dynamic-form-control.model\";\nimport { DynamicFormArrayGroupModel } from \"../model/form-array/dynamic-form-array.model\";\nimport { DynamicFormControl } from \"../component/dynamic-form-control.interface\";\nimport {\n    DynamicTemplateDirective,\n    DYNAMIC_TEMPLATE_DIRECTIVE_ALIGNMENT\n} from \"../directive/dynamic-template.directive\";\nimport { isObject } from \"../utils/core.utils\";\n\nexport type DynamicFormLayout = { [id: string]: DynamicFormControlLayout };\n\nexport type DynamicFormControlMapFn = (model: DynamicFormControlModel) => Type<DynamicFormControl> | null;\n\nexport type DynamicFormControlTemplates = QueryList<DynamicTemplateDirective> | DynamicTemplateDirective[] | undefined;\n\nexport const DYNAMIC_FORM_CONTROL_MAP_FN = new InjectionToken<DynamicFormControlMapFn>(\"DYNAMIC_FORM_CONTROL_MAP_FN\");\n\n@Injectable({\n    providedIn: \"root\"\n})\nexport class DynamicFormLayoutService {\n\n    constructor(@Inject(DYNAMIC_FORM_CONTROL_MAP_FN) @Optional() private readonly DYNAMIC_FORM_CONTROL_MAP_FN: any) {\n        this.DYNAMIC_FORM_CONTROL_MAP_FN = DYNAMIC_FORM_CONTROL_MAP_FN as DynamicFormControlMapFn;\n    }\n\n    findById(id: string, formLayout: DynamicFormLayout | null): DynamicFormControlLayout | null {\n\n        if (isObject(formLayout)) {\n\n            for (let key of Object.keys(formLayout)) {\n\n                if (key === id) {\n                    return formLayout[key];\n                }\n            }\n        }\n\n        return null;\n    }\n\n    filterTemplatesByModel(model: DynamicFormControlModel, templates: DynamicFormControlTemplates): DynamicTemplateDirective[] {\n\n        const filterCallback: (template: DynamicTemplateDirective) => boolean = (template: DynamicTemplateDirective) => {\n            return template.modelId === model.id || template.modelType === model.type;\n        };\n\n        if (templates instanceof QueryList) {\n            return templates.filter(filterCallback);\n\n        } else if (Array.isArray(templates)) {\n            return templates.filter(filterCallback);\n        }\n\n        return [];\n    }\n\n    getAlignedTemplate(model: DynamicFormControlModel, templates: DynamicFormControlTemplates, alignment: DYNAMIC_TEMPLATE_DIRECTIVE_ALIGNMENT): DynamicTemplateDirective | undefined {\n\n        return this.filterTemplatesByModel(model, templates)\n            .find(template => template.as === null && template.align === alignment);\n    }\n    /*\n    getIndexedTemplates(model: DynamicFormControlModel, templates: DynamicFormControlTemplates): DynamicTemplateDirective[] | undefined {\n        return this.filterTemplatesByModel(model, templates).filter(template => template.as === null);\n    }\n    */\n    getStartTemplate(model: DynamicFormControlModel, templates: DynamicFormControlTemplates): DynamicTemplateDirective | undefined {\n        return this.getAlignedTemplate(model, templates, DYNAMIC_TEMPLATE_DIRECTIVE_ALIGNMENT.Start);\n    }\n\n    getEndTemplate(model: DynamicFormControlModel, templates: DynamicFormControlTemplates): DynamicTemplateDirective | undefined {\n        return this.getAlignedTemplate(model, templates, DYNAMIC_TEMPLATE_DIRECTIVE_ALIGNMENT.End);\n    }\n\n    getClass(layout: DynamicFormControlLayout | null, context: DynamicFormControlLayoutContext, place: DynamicFormControlLayoutPlace): string {\n\n        if (layout !== null && layout.hasOwnProperty(context)) {\n\n            let config = layout[context] as DynamicFormControlLayoutConfig;\n\n            if (config.hasOwnProperty(place)) {\n                return config[place] as string;\n            }\n        }\n\n        return \"\";\n    }\n\n    getElementId(model: DynamicFormControlModel): string {\n\n        let id = model.id,\n            parent = model.parent;\n\n        while (parent !== null) {\n\n            if (parent instanceof DynamicFormArrayGroupModel) {\n\n                id = `${parent.context.id}-${parent.index}-${model.id}`;\n                break;\n            }\n\n            parent = parent.parent;\n        }\n\n        return id;\n    }\n\n    getCustomComponentType(model: DynamicFormControlModel): Type<DynamicFormControl> | null {\n\n        if (this.DYNAMIC_FORM_CONTROL_MAP_FN) {\n            return this.DYNAMIC_FORM_CONTROL_MAP_FN(model);\n        }\n\n        return null;\n    }\n}\n","import { CommonModule } from \"@angular/common\";\nimport { ModuleWithProviders, NgModule } from \"@angular/core\";\nimport { ReactiveFormsModule } from \"@angular/forms\";\nimport { DynamicIdDirective } from \"./directive/dynamic-id.directive\";\nimport { DynamicListDirective } from \"./directive/dynamic-list.directive\";\nimport { DynamicTemplateDirective } from \"./directive/dynamic-template.directive\";\nimport { DynamicFormService } from \"./service/dynamic-form.service\";\nimport { DynamicFormLayoutService } from \"./service/dynamic-form-layout.service\";\nimport { DynamicFormValidationService } from \"./service/dynamic-form-validation.service\";\n\n@NgModule({\n    imports: [\n        CommonModule,\n        ReactiveFormsModule\n    ],\n    declarations: [\n        DynamicIdDirective,\n        DynamicListDirective,\n        DynamicTemplateDirective\n    ],\n    exports: [\n        DynamicIdDirective,\n        DynamicListDirective,\n        DynamicTemplateDirective\n    ]\n})\nexport class DynamicFormsCoreModule {\n\n    static forRoot(): ModuleWithProviders {\n\n        return {\n\n            ngModule: DynamicFormsCoreModule,\n\n            providers: [\n                DynamicFormService,\n                DynamicFormLayoutService,\n                DynamicFormValidationService\n            ]\n        };\n    }\n}\n"],"names":["isBoolean","value","isFunction","isNumber","isObject","isString","layoutService","validationService","this","Object","DynamicFormControlComponent","group","get","model","id","getElementId","createErrorMessages","control","_hasFocus","invalid","valid","hasErrorMessages","touched","hasFocus","isInvalid","context","place","controlLayout","layout","getClass","$event","Event","stopPropagation","blur","emit","change","onChange","valueUpdates","next","checked","type","bypass","emitter","customEvent","customEventType","focus","__extends","DynamicFormArrayComponent","getStartTemplate","templates","getEndTemplate","Blur","Change","Custom","Focus","isDynamicFormControlEvent","hasOwnProperty","formService","DynamicFormComponent","_index","findById","formLayout","DynamicFormControlEventType","extendStatics","d","b","setPrototypeOf","__proto__","Array","p","__","constructor","prototype","create","config","Promise","closed","errorObject","tryCatchTarget","fn","UnsubscriptionErrorImpl","Error","errors","name","Subscription","unsubscribe","hasErrors","_parent","_parents","index","e","UnsubscriptionError","isArray","_subscriptions","len","sub","err","teardown","subscription","subscriptions","subscriptionIndex","indexOf","parent","Math","Subscriber","_super","_this","destination","destinationOrNext","syncErrorThrowable","tslib_1.__extends","error","subscriber","isStopped","_next","_error","_complete","SafeSubscriber","observerOrNext","complete","_context","_parentSubscriber","useDeprecatedSynchronousErrorHandling","__tryOrSetError","__tryOrUnsub","syncErrorValue","wrappedComplete","syncErrorThrown","hostReportError","Observable","subscribe","lift","operator","observable","source","sink","nextOrObserver","_subscribe","_a","closed_1","canReportError","forEach","promiseCtor","reject","operations","length","fns","input","toPromise","getPromiseCtor","ObjectUnsubscribedErrorImpl","message","SubjectSubscription","subject","observers","subscriberIndex","SubjectSubscriber","Subject","i","hasError","thrownError","asObservable","AnonymousSubject","RefCountOperator","connectable","refCounter","RefCountSubscriber","refCount","_refCount","connection","sharedConnection","getSubject","ConnectableSubscriber","connect","_isComplete","_subject","scheduler","array","add","result","args","_isScalar","isObservable","MapOperator","project","MapSubscriber","thisArg","count","METADATA_KEY_SERIALIZABLE","serializable","target","key","Reflect","defineMetadata","getSerializables","serializables","metadata","getMetadata","push","serialize","reduce","prev","prop","asyncValidators","errorMessages","hidden","label","labelTooltip","controlTooltip","relation","updateOn","validators","disabled","disabledUpdates","DynamicFormControlModel","_disabled","__decorate","additional","hint","required","tabIndex","undefined","DynamicFormValueControlModel","_value","defaultValue","$implicit","DynamicFormArrayGroupModel","DYNAMIC_FORM_CONTROL_TYPE_ARRAY","groupFactory","groupAsyncValidators","groupPrototype","groupValidators","initialCount","groups","arrayGroup","addGroup","DynamicFormArrayModel","insertGroup","splice","updateGroupIndex","step","labelPosition","DynamicCheckControlModel","DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX","indeterminate","AUTOFILL_TOKEN_BILLING","AUTOFILL_TOKEN_SHIPPING","AUTOFILL_TOKENS_ADDRESS","AUTOFILL_TOKENS_CONTACT","AUTOFILL_FIELD_STREET_ADDRESS","AUTOFILL_FIELD_ADDRESS_LINE_1","AUTOFILL_FIELD_ADDRESS_LINE_2","AUTOFILL_FIELD_ADDRESS_LINE_3","AUTOFILL_FIELD_ADDRESS_LEVEL_4","AUTOFILL_FIELD_ADDRESS_LEVEL_3","AUTOFILL_FIELD_ADDRESS_LEVEL_2","AUTOFILL_FIELD_ADDRESS_LEVEL_1","AUTOFILL_FIELD_HONORIFIC_PREFIX","AUTOFILL_FIELD_GIVEN_NAME","AUTOFILL_FIELD_ADDITIONAL_NAME","AUTOFILL_FIELD_FAMILY_NAME","AUTOFILL_FIELD_HONORIFIC_SUFFIX","AUTOFILL_FIELD_NICKNAME","AUTOFILL_FIELD_USERNAME","AUTOFILL_FIELD_NEW_PASSWORD","AUTOFILL_FIELD_CURRENT_PASSWORD","AUTOFILL_FIELD_ORGANIZATION_TITLE","AUTOFILL_FIELD_ORGANIZATION","AUTOFILL_FIELD_COUNTRY","AUTOFILL_FIELD_COUNTRY_NAME","AUTOFILL_FIELD_POSTAL_CODE","AUTOFILL_FIELD_CC_NAME","AUTOFILL_FIELD_CC_GIVEN_NAME","AUTOFILL_FIELD_CC_ADDITIONAL_NAME","AUTOFILL_FIELD_CC_FAMILY_NAME","AUTOFILL_FIELD_CC_NUMBER","AUTOFILL_FIELD_CC_EXP_MONTH","AUTOFILL_FIELD_CC_EXP_YEAR","AUTOFILL_FIELD_CC_TYPE","AUTOFILL_FIELD_TRANSACTION_CURRENCY","AUTOFILL_FIELD_TRANSACTION_AMOUNT","AUTOFILL_FIELD_LANGUAGE","AUTOFILL_FIELD_BDAY_DAY","AUTOFILL_FIELD_BDAY_MONTH","AUTOFILL_FIELD_BDAY_YEAR","AUTOFILL_FIELDS","AUTOFILL_FIELD_TEL_COUNTRY_CODE","AUTOFILL_FIELD_TEL_NATIONAL","AUTOFILL_FIELD_TEL_AREA_CODE","AUTOFILL_FIELD_TEL_LOCAL","AUTOFILL_FIELD_TEL_LOCAL_PREFIX","AUTOFILL_FIELD_TEL_LOCAL_SUFFIX","AUTOFILL_FIELD_TEL_LOCAL_EXTENSION","AUTOFILL_FIELDS_CONTACT","autoComplete","autoFocus","maxLength","minLength","placeholder","prefix","readOnly","spellCheck","suffix","maskToString","mask","RegExp","toString","map","maskFromString","startsWith","endsWith","slice","parseReviver","_key","test","Date","DoOperator","TapSubscriber","noop","_tapComplete","_tapError","_tapNext","DYNAMIC_FORM_CONTROL_TYPE_INPUT","accept","inputType","max","min","multiple","pattern","list","_listId","DynamicInputModel","list$","_list","of","pipe","json","toJSON","DynamicInputControlModel","DYNAMIC_FORM_CONTROL_ACTION_DISABLE","DYNAMIC_FORM_CONTROL_ACTION_ENABLE","DYNAMIC_FORM_CONTROL_CONNECTIVE_AND","DYNAMIC_FORM_CONTROL_CONNECTIVE_OR","findActivationRelation","relGroups","rel","find","action","getRelatedFormControls","controlGroup","controls","relGroup","when","some","controlElement","isFormControlToBeDisabled","_formGroup","formGroup","toBeDisabled","connective","status","componentFactoryResolver","DynamicFormControlContainerComponent","changes","groupChange","modelChange","destroyFormControlComponent","createFormControlComponent","valueChanges","onControlValueChanges","onModelDisabledUpdates","onModelValueUpdates","setControlRelations","inputTemplateList","contentTemplateList","componentType","componentFactory","resolveComponentFactory","componentViewContainerRef","clear","componentRef","createComponent","instance","componentSubscriptions","onBlur","onFocus","onCustomEvent","destroy","relActivation","rel_1","updateModelDisabled","statusChanges","setValue","disable","enable","inputElement","srcElement","files","createDynamicFormControlEvent","DynamicTemplateableFormControlComponent","filterTemplatesByModel","template","bindTemplate","as","templateDirectives","has","property","viewChild","mapTemplate","elementRef","renderer","DynamicIdDirective","dynamicId","setAttribute","nativeElement","Directive","selector","ElementRef","Renderer2","Input","DynamicListDirective","listId","Start","End","templateRef","DYNAMIC_TEMPLATE_DIRECTIVE_ALIGNMENT","TemplateRef","format","DynamicFormOption","text","options","DynamicOptionControlModel","options$","_options","optionConfig","updateOptions$","optionsConfig","insert","option","_i","indices","DYNAMIC_FORM_CONTROL_TYPE_GROUP","legend","DynamicFormGroupModel","controlModel","DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX_GROUP","DynamicCheckboxGroupModel","DYNAMIC_FORM_CONTROL_TYPE_COLORPICKER","inline","DYNAMIC_FORM_CONTROL_TYPE_DATEPICKER","focusedDate","toggleIcon","toggleLabel","DynamicDateControlModel","DYNAMIC_FORM_CONTROL_TYPE_EDITOR","DYNAMIC_FORM_CONTROL_TYPE_FILE_UPLOAD","autoUpload","maxSize","minSize","removeUrl","showFileList","url","DynamicFileControlModel","DYNAMIC_FORM_CONTROL_TYPE_RADIO_GROUP","DynamicRadioGroupModel","DYNAMIC_FORM_CONTROL_TYPE_RATING","DYNAMIC_FORM_CONTROL_TYPE_SELECT","compareWithFn","looseIdentical","filterable","DynamicSelectModel","DYNAMIC_FORM_CONTROL_TYPE_SLIDER","vertical","DYNAMIC_FORM_CONTROL_TYPE_SWITCH","offLabel","onLabel","DYNAMIC_FORM_CONTROL_TYPE_TEXTAREA","cols","rows","wrap","DYNAMIC_FORM_CONTROL_TYPE_TIMEPICKER","meridian","showSeconds","DYNAMIC_VALIDATORS","InjectionToken","NG_VALIDATORS","NG_ASYNC_VALIDATORS","DynamicFormValidationService","validatorName","validatorArgs","validatorsToken","validatorFn","Validators","validatorsConfig","validatorFns","keys","validatorConfigKey","validatorConfigValue","isValidatorDescriptor","descriptor","getValidatorFn","replace","_match","expression","propertySource","propertyName","getValidatorFns","asyncValidatorsConfig","clearValidators","setValidators","getValidators","clearAsyncValidators","setAsyncValidators","getAsyncValidators","messages","messagesConfig_1","validationErrorKey","messageKey","validationError","getError","messageTemplate","parseErrorMessageConfig","Injectable","providedIn","Optional","Inject","Map","DynamicFormService","isFormHook","formArrayModel","createAbstractControlOptions","size","groupModel","groupOptions","createFormGroup","FormArray","formModel","createFormArray","controlState","controlOptions","FormControl","FormGroup","path","getPathSegment","unshift","models","insertFormGroupControl","_formModel","move","controlName","idx","addControl","removeControl","remove","formArray","newIndex","moveUp","movingGroups_1","at","formControl","position","setControl","moveGroup","removeAt","removeGroup","removeFormArrayGroup","findByIdFn","groupModel_1","formModelJSON","JSON","parse","formArrayModel_1","fromJSON","DynamicCheckboxModel","DynamicColorPickerModel","DynamicDatePickerModel","DynamicEditorModel","DynamicFileUploadModel","inputModel","DynamicRatingModel","DynamicSliderModel","DynamicSwitchModel","DynamicTextAreaModel","DynamicTimePickerModel","DYNAMIC_FORM_CONTROL_MAP_FN","DynamicFormLayoutService","filterCallback","modelId","modelType","QueryList","filter","alignment","align","getAlignedTemplate","DynamicFormsCoreModule","ngModule","providers","NgModule","imports","CommonModule","ReactiveFormsModule","declarations","DynamicTemplateDirective","exports","token","tokens","toExpression","total","currentValue","tokensAddress","tokensContact","fields","fieldsContact"],"mappings":"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"}